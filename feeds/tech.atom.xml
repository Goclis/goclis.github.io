<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Logging</title><link href="http://goclis.github.io/" rel="alternate"></link><link href="http://goclis.github.io/feeds/tech.atom.xml" rel="self"></link><id>http://goclis.github.io/</id><updated>2017-04-10T22:29:42+08:00</updated><entry><title>Call convention &amp; Name mangling</title><link href="http://goclis.github.io/posts/2017/04/10/Call%20convention%20&amp;%20Name%20mangling.html" rel="alternate"></link><updated>2017-04-10T22:29:42+08:00</updated><author><name>Goclis Yao</name></author><id>tag:goclis.github.io,2017-04-10:posts/2017/04/10/Call convention &amp; Name mangling.html</id><summary type="html">&lt;p&gt;标题只是为了满足强迫症，文中对于 Call convention 还是使用中文翻译的&lt;strong&gt;调用约定&lt;/strong&gt;，但 Name mangling 因为不知道怎么翻译好，就保持吧。&lt;/p&gt;
&lt;p&gt;之前同学在聊面试的时候提到被问过调用约定（Call convention）相关的问题，突然想起来自己虽然知道这个东西影响的是方法调用（比如参数如何传递、调用栈清理等），但是并不记得每个类型的调用约定存在的作用以及具体内容，于是查了一下。&lt;/p&gt;
&lt;h2 id="call-convention"&gt;调用约定（Call convention）&lt;a class="headerlink" href="#call-convention" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;调用约定规定了一个方法在被调用的时候需要遵循的一些内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;参数如何传递，包括使用寄存器还是堆栈或是混合、从左到右压栈还是从右到左压栈。&lt;/li&gt;
&lt;li&gt;调用栈最终由谁负责恢复？调用者（Caller）或被调用者（Callee）。&lt;/li&gt;
&lt;li&gt;方法最终在链接时使用的符号名。&lt;/li&gt;
&lt;li&gt;更多...&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;显然，调用约定是 &lt;a href="https://www.wikiwand.com/en/Application_binary_interface"&gt;ABI（Application binary interface）&lt;/a&gt; 层面的东西，而且这玩意有很多类型，历史原因在于以前提供机器的那波厂商没有顺带提供操作系统和编译器，而是把这两块交给了市场，于是各家自己玩自己的，弄出来各种自己的标准，所以 ABI 兼容就别想了。虽然也有如 stdcall 这样的标准出来让各家一起遵守，但是至今我好像也没怎么看到关于 ABI 兼容的实例（希望是我没看到吧）。&lt;/p&gt;
&lt;p&gt;下面是常见的几种调用约定的规定：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;cdecl：广泛被 C 编译器使用（Visual Studio 2015 在 Win32 Debug 下默认使用这个），使用栈传递参数、从右到左压栈、栈由调用者清理、符号名如 &lt;code&gt;_func&lt;/code&gt;（方法名前加下划线）。&lt;/li&gt;
&lt;li&gt;stdcall：使用栈传递参数、从右到左、栈由被调用者清理、符号名如 &lt;code&gt;_func@8&lt;/code&gt;（方法名前加下划线，后面使用 @ 拼接调用参数的总大小）。&lt;/li&gt;
&lt;li&gt;fastcall：类似 stdcall，但会将前两个小于等于 DWORD 的参数使用寄存器 ECX 和 EDX 传递，剩余的使用栈，另外符号名如 &lt;code&gt;@func@8&lt;/code&gt;（相对于 stdcall，把前面的下划线换成 @）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可以看到，调用约定对符号名也有一定的规定，这让我想起来 C++ 的 &lt;a href="https://www.wikiwand.com/en/Name_mangling"&gt;Name mangling&lt;/a&gt;，这个东西同样对符号名有规定，所以我当时好奇当它和调用约定结合起来后会怎么样？&lt;/p&gt;
&lt;h2 id="name-mangling"&gt;Name mangling&lt;a class="headerlink" href="#name-mangling" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;调用约定在一定程度上告诉了编译器该如何生成一个方法的内容、如何生成调用了这个方法的代码的内容以及链接时该使用怎样的符号。&lt;/p&gt;
&lt;p&gt;而 Name mangling 只做一件事，就是一个方法名对应的符号名该是什么，又名 Name decoration。我个人理解 C++ 引入这个是为了对付重载，毕竟允许方法同名后就没办法仅通过名字来在链接时像 C 那样区分各个符号了。不过，查了一些资料后发现，其实 C 的那种在方法名前面加下划线（就是 cdecl 的规定）就是它的 Name mangling，所以不能说 Name mangling 是 C++ 特有的。&lt;/p&gt;
&lt;p&gt;瞎扯了一堆，做实验看看两个合起来会对符号名有什么样的影响吧（虽然我觉得这玩意应该又是一件完全由编译器决定的事，不过还是试试看吧）。&lt;/p&gt;
&lt;h2 id="_1"&gt;实验&lt;a class="headerlink" href="#_1" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;用的 Visual Studio 2015 Community Edition，Configuration 选择默认的 Win32 Debug，查看符号的方式也比较简单，看生成产生的链接错误即可。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ name mangling &amp;amp; cdecl&lt;/span&gt;
&lt;span class="c1"&gt;// unresolved external symbol "void __cdecl F(void)" (?F@@YAXXZ) referenced in function _main&lt;/span&gt;
&lt;span class="c1"&gt;// void F();&lt;/span&gt;

&lt;span class="c1"&gt;// C++ name mangling &amp;amp; stdcall&lt;/span&gt;
&lt;span class="c1"&gt;// unresolved external symbol "void __stdcall F(void)" (?F@@YGXXZ) referenced in function _main&lt;/span&gt;
&lt;span class="c1"&gt;// void __stdcall F(); &lt;/span&gt;

&lt;span class="c1"&gt;// C++ name mangling &amp;amp; fastcall&lt;/span&gt;
&lt;span class="c1"&gt;// unresolved external symbol "void __fastcall F(void)" (?F@@YIXXZ) referenced in function _main&lt;/span&gt;
&lt;span class="c1"&gt;// void __fastcall F();&lt;/span&gt;

&lt;span class="c1"&gt;// C name mangling &amp;amp; cdecl&lt;/span&gt;
&lt;span class="c1"&gt;// unresolved external symbol _F referenced in function _main&lt;/span&gt;
&lt;span class="c1"&gt;// extern "C" void F();&lt;/span&gt;

&lt;span class="c1"&gt;// C name mangling &amp;amp; stdcall&lt;/span&gt;
&lt;span class="c1"&gt;// unresolved external symbol _F@0 referenced in function _main&lt;/span&gt;
&lt;span class="c1"&gt;// extern "C" void __stdcall F();&lt;/span&gt;

&lt;span class="c1"&gt;// C name mangling &amp;amp; fastcall&lt;/span&gt;
&lt;span class="c1"&gt;// unresolved external symbol @F@0 referenced in function _main&lt;/span&gt;
&lt;span class="k"&gt;extern&lt;/span&gt; &lt;span class="s"&gt;"C"&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="kr"&gt;__fastcall&lt;/span&gt;  &lt;span class="n"&gt;F&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;F&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码大概的目的就是测试一下 cdecl、stdcall、fastcall 在混合 C 和 C++ 的 Name mangling 时，会生成怎样的符号，代码里使用 &lt;code&gt;extern "C"&lt;/code&gt; 来让编译器采用 C Name mangling。&lt;/p&gt;
&lt;p&gt;从结果来看，两者会共同影响最终的符号，= =# 好像也没有更多的什么好解释了。如果还对调用栈的清理感兴趣的话，可以增加点参数，实现一下每个方法，然后反汇编看一下即可。&lt;/p&gt;
&lt;h2 id="_2"&gt;写在最后&lt;a class="headerlink" href="#_2" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;像这种 ABI 层面的一些规定，我们大多时候可能不会去在意，但是有些地方的开发可能会强制地要求你使用某种特定的规定（比如有个同学提到过他开发驱动的时候好像必须使用 cdecl），所以稍微了解下也没什么坏处吧。&lt;/p&gt;
&lt;p&gt;至于 ABI 相关的内容，除了本文提到了两个，还有一个 type representations，大概是指与数据相关的内容，比如数据的大小、对齐等内容？这里就不展开了（懒。&lt;/p&gt;
&lt;h2 id="_3"&gt;参考资料&lt;a class="headerlink" href="#_3" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.wikiwand.com/en/X86_calling_conventions"&gt;x86 Call convention - Wikipedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://msdn.microsoft.com/en-us/library/984x0h58.aspx"&gt;Argument Passing and Naming Conventions - MSDN&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://msdn.microsoft.com/en-us/library/zkwh89ks.aspx"&gt;cdecl - MSDN&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.csdn.net/fly2k5/article/details/544112"&gt;cdecl、stdcall、fastcall 函数调用约定区别 - CSDN&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.wikiwand.com/en/Name_mangling"&gt;Name mangling - Wikipedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.wikiwand.com/en/Application_binary_interface"&gt;Application binary interface - Wikipedia&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary><category term="Call convention"></category><category term="调用约定"></category><category term="Name mangling"></category><category term="ABI"></category></entry><entry><title>MS Visual Studio对C++多继承的相关实现</title><link href="http://goclis.github.io/posts/2016/09/25/ms-visual-studio-implementation-of-cpp-multiple-inheritance.html" rel="alternate"></link><updated>2016-09-25T15:31:00+08:00</updated><author><name>Goclis Yao</name></author><id>tag:goclis.github.io,2016-09-25:posts/2016/09/25/ms-visual-studio-implementation-of-cpp-multiple-inheritance.html</id><summary type="html">&lt;p&gt;&lt;em&gt;本文的内容来自于在VS2013中的实验，只能说明一种可行的实现途径，不代表编译器必须这样实现。后续内容中如未特殊提及，编译器代指VS2013。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;首先，我们来明确一个观点：&lt;strong&gt;在类成员方法中，this指针是否一定要指向这个对象的内存起始处？&lt;/strong&gt;答案是不一定，指向起始处当然是很方便我们这些脑算成员变量偏移的，因为只用做加法就行了，但是对于编译器而言，它只需要确定好一个关于this指向的原则，随后基于这个原则，不管偏移要加法还是减法，对它来说都是没什么区别的。因此，this的指向实际上是编译器自己决定的，它可以遵照常规的想法，在进入成员方法代码前，把this调整至对象内存起始，或者是为了性能，采用它自己的原则。&lt;/p&gt;
&lt;p&gt;显然，VS这样的编译器使用的是后者，它出于性能考虑，约定了自己的原则：&lt;strong&gt;this指针在一个类成员方法中的指向，取决于该方法的来源。&lt;/strong&gt;具体来说：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果该方法首次声明在本类中，那么this指向本类对象的内存起始位置。&lt;/li&gt;
&lt;li&gt;如果该方法首次声明不在本类中，即来自于父类，那么this应指向第一个声明此方法的父类，也就是多继承的情况下，在子类的视角中，顺序靠前的父类覆盖靠后的父类。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于类成员方法是可以在继承关系中调用的，即子类对象可以调用父类的public成员方法。那么，按照这个原则中的第2条，编译器需要做一些调整工作。&lt;/p&gt;
&lt;p&gt;下面举个例子，并结合例子来讲讲&lt;strong&gt;this调整&lt;/strong&gt;的过程：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;namespace&lt;/span&gt; &lt;span class="n"&gt;base_adjust_rule&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;P1&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;virtual&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;f1&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;P2&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;virtual&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;f1&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
    &lt;span class="k"&gt;virtual&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;f2&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;f3&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;P3&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;virtual&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;f2&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
    &lt;span class="k"&gt;virtual&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;f3&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;f4&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;C&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;P1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;P2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;P3&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;virtual&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;f1&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
    &lt;span class="k"&gt;virtual&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;f2&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
    &lt;span class="k"&gt;virtual&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;f3&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;test&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;C&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;P1&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pp1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pc&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;P2&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pp2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pc&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;P3&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pp3&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pc&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;pc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;f4&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;pc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;f1&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;pc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;f2&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;pc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;f3&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;示例代码很简单，子类C继承三个父类，测试代码中使用子类的指针去调用一系列成员方法，下面依次来从编译器的角度看看每个调用涉及的一些细节以及调整实现。&lt;/p&gt;
&lt;p&gt;首先来看&lt;strong&gt;pc-&amp;gt;f4()&lt;/strong&gt;。从编译器的角度来看，pc的类型是C*，调用的方法f4的首次声明在父类P3中，并且C没有覆盖f4，所以调用的是P3::f4，按照原则，进入此方法前，this应该指向C对象中的P3部分的开始，即this应该调整到和示例代码中的pp3相等。推断完毕，来看看编译器是怎么进行这个调整的，上反汇编：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://ww2.sinaimg.cn/large/006y8lVagw1f85oejcg38j31220ktgp5.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;很明显，VS生成的代码中利用ecx来传递this指针，可以看到，在进行call之前，编译器加入了一句&lt;code&gt;add ecx 8&lt;/code&gt;，目的就是将this调整到和pp3一致，简单地计算一下右边监视变量的值确定了这一点。&lt;/p&gt;
&lt;p&gt;接着看&lt;strong&gt;pc-&amp;gt;f1()&lt;/strong&gt;。按照原则，要把this调整至P1部分，而因为P1是C的第一个父类，在VS的多继承内存布局中，第一个父类的指针和子类指针指向相同，所以不需要进行任何调整，ecx直接等于pc，然后通过虚表指针获取f1的地址（放至eax），就执行call了。反汇编图证明了这一点。类似于pc-&amp;gt;f4()，&lt;strong&gt;pc-&amp;gt;f2()&lt;/strong&gt;和&lt;strong&gt;pc-&amp;gt;f3()&lt;/strong&gt;都要进行调整，只是各自的偏移不同而已。&lt;/p&gt;
&lt;p&gt;结合示例代码及反汇编图，可以明确，VS确实是在遵守我们一开始所说的原则的，并且，即使你使用的是类对象而非对象指针去调用方法，原则依旧保持。如果感兴趣且想做进一步验证的话，可以在方法中加入一些访问成员变量的代码，然后在方法内部反汇编，查看它访问变量时的偏移计算，从而确定this指向。&lt;/p&gt;
&lt;p&gt;上面的示例代码比较简单，都是使用pc去访问方法，而对于编译器来说，从类C的角度它可以在编译期就完全确定如何调整，所以才能生成一系列的add代码。但如果从P2的角度去分析的话，编译器将无法在编译期确定这些偏移量，下面将说明这一点并讲讲编译器如何处理这种情况。&lt;/p&gt;
&lt;p&gt;继承结构不变，测试代码更换如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;test2&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;P2&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;p21&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;P2&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;p22&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;P2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;p21&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;f1&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;p22&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;f1&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到，在编译期是没法确定如何对P2*进行调整的，对于C而言，f1是来自于P1的，它要调整至P1，而对于P2而言，它不需要调整，因为它的f1来自于自身。所以，这个调整只能放到运行期，依赖于对象内存中的内容（实际上就是虚表）。看看内存布局，单步一下反汇编代码就可以明白VS的处理了，截图如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://ww3.sinaimg.cn/large/006y8lVagw1f85rndokmlj31b10igjwd.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，两个调用的反汇编代码完全相同，即访问虚表中的第一项，然后调用它，传入的参数即为调用时使用的指针。而从右边可以看到，对于p22，我们知道是不需要调整的，所以虚表中该项直接就是目标函数P2::f1；而对于p21，需要调整，所以编译器为C的内存布局中B部分虚表的第一项生成了thunk代码，并且此代码的作用是调整偏移再跳转（见下图），调整的目标也是按照原则使得this指向P1部分，调试器里对于虚表中该项的命名提示性也很强，就叫&lt;strong&gt;adjustor{4}&lt;/strong&gt;，大括号中的内容是偏移量。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://ww2.sinaimg.cn/large/006y8lVagw1f85rv1ytbbj30fc03lq32.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;注意，这里thunk是为类C生成的，因为C的父类中出现了同名的virtual方法。&lt;/p&gt;
&lt;p&gt;提到了thunk，就顺便讲讲另外一种情况下的多态访问，即利用成员函数指针。这里的多态访问是指：使用指针或者引用去调用成员函数指针，需要保持多态语义。按照上面示例的继承结构，下面的代码中的调用都等价（子类指针是可以调用父类成员函数指针的）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;test3&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;C&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;P1&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pp1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pc&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;P2&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pp2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pc&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;pp1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;f1&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;pp2&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;f1&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;p1f1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;P1&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;f1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;*&lt;/span&gt;&lt;span class="n"&gt;p1f1&lt;/span&gt;&lt;span class="p"&gt;)();&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pp1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;*&lt;/span&gt;&lt;span class="n"&gt;p1f1&lt;/span&gt;&lt;span class="p"&gt;)();&lt;/span&gt;
    &lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;p2f&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;P2&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;f1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;*&lt;/span&gt;&lt;span class="n"&gt;p2f&lt;/span&gt;&lt;span class="p"&gt;)();&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pp2&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;*&lt;/span&gt;&lt;span class="n"&gt;p2f&lt;/span&gt;&lt;span class="p"&gt;)();&lt;/span&gt;

    &lt;span class="c1"&gt;// p2f的类型为void (P2::*)()，所以可以进行如下赋值&lt;/span&gt;
    &lt;span class="n"&gt;p2f&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;P2&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;f3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;*&lt;/span&gt;&lt;span class="n"&gt;p2f&lt;/span&gt;&lt;span class="p"&gt;)();&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pp2&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;*&lt;/span&gt;&lt;span class="n"&gt;p2f&lt;/span&gt;&lt;span class="p"&gt;)();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于调用成员函数地址，VS也有类似一开始那样的规定，即在进入该方法前，需要将this指向调整至对象内存中该方法所属的类的开始部分，即调用&amp;amp;P1::f1要调整成P1，调用&amp;amp;P2::f1要调整至P2，因为只有该类本身及子类的指针或对象能调用，这个调整在编译期就能完成，然后把调整完后的指针传入成员函数地址所代表的函数即可。但是，要应对成员函数是虚函数和普通函数，前者需要访问虚表，而后者是固定地址，这项工作就必须通过运行期来完成了，所以，对每一个取地址的虚成员函数，都有对应的thunk代码，代码完成的工作就是访问虚表的对应项的函数，然后传递参数。这个通过查看反汇编同样能够证明，见下面的图片：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://ww1.sinaimg.cn/large/006y8lVagw1f85un5958ij31b80ketd8.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://ww2.sinaimg.cn/large/006y8lVagw1f85up231jkj31b20lu436.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;简单解释一下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;pc和pp1相等，都指向了P1部分，所以它们调用不需要任何调整。&lt;/li&gt;
&lt;li&gt;pp2指向P2部分，所以调用不调整。&lt;/li&gt;
&lt;li&gt;pc指向P1部分，所以调用&amp;amp;P2::f1和&amp;amp;P2::f3的时候都要调整。&lt;/li&gt;
&lt;li&gt;查看右边（p2f及p1f1）可以看到，对于虚函数，都是诸如&lt;code&gt;[thunk]:base_adjust_rule::P1::'vcall'{0, {flat}}&lt;/code&gt;这样的内容，而普通函数则无thunk。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果你仔细跟踪(pc-&amp;gt;*&amp;amp;P2::f1)()，你会发现，编译器在编译期把指针调整成了P2，而运行期，因为f1来自于P1，又要重新调整回去，很傻，但是没办法，利用成员函数指针来调用虚函数，在父类中存在同名时，就是会产生这样的一个代价。&lt;/p&gt;
&lt;p&gt;这个实验至少告诉我们普通用户一点：尽量别让多个父类中出现同名方法，否则会导致一次额外的jmp。= =#这种看现象猜原则的过程也是蛮痛苦的，不过还好，总算是补完了。&lt;/p&gt;</summary><category term="多继承"></category><category term="C++编译器thunk"></category><category term="成员函数指针"></category><category term="this指针"></category></entry><entry><title>和Shadowsocks一起科学上网</title><link href="http://goclis.github.io/posts/2016/05/27/fuck-the-gfw-with-shadowsocks.html" rel="alternate"></link><updated>2016-11-21T16:45:00+08:00</updated><author><name>Goclis Yao</name></author><id>tag:goclis.github.io,2016-05-27:posts/2016/05/27/fuck-the-gfw-with-shadowsocks.html</id><summary type="html">
&lt;p&gt;拖延症晚期，本来上上个月把新机器折腾好了之后就想写这个内容的，丢到Todo里后就没理它了，今天发现还有一个更早前想写的内容至今也没开始码。
这篇东西呢，没什么干货，只是一个整理，记下如何利用Shadowsocks来科学上网，包括VPS相关的内容。因此，对于不同的VPS提供商、不同的OS可能不适用，可以自行搜索。&lt;/p&gt;
&lt;h3 id="vps"&gt;VPS搭建服务器&lt;a class="headerlink" href="#vps" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;稍微讲讲VPS的选择吧，一句话，&lt;strong&gt;你选的VPS所在的网络必须能够访问你的目标网站&lt;/strong&gt;，比如你想通过VPS上Google，那选阿里云你就只会一脸懵逼了。&lt;/p&gt;
&lt;p&gt;穷人表示我用的是&lt;a href="https://www.digitalocean.com"&gt;DigitalOcean&lt;/a&gt;，还是最便宜的$5一个月那种，不过也够用了，流量好像是不限制的，带宽貌似是百兆，以下简称DO。&lt;/p&gt;
&lt;p&gt;额，毕竟不是软文也不是小白教程，就不截没必要的图了。Droplet选的Ubuntu 14.04，创建完毕后，DO会给你发邮件，里面有VPS的IP以及root用户的密码，用ssh工具（Windows下可以下载putty）连接上去进行如设置root密码等一系列基础的配置后即可：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;*unix: &lt;code&gt;ssh root@IP&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Windows: 在putty里填写IP，然后点击连接&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="ipv6"&gt;开启IPv6&lt;a class="headerlink" href="#ipv6" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;默认的情况下DO是关闭IPv6的，可以到Droplet的管理页面中开启，系统会为VPS分配相应的IPv6地址，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://ww1.sinaimg.cn/large/006y8lVagw1f86x20lhcej30su0eg3zg.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;接着需要到VPS上&lt;a href="http://4b3r.com/digitalocean-enable-ipv6/"&gt;配置IPv6&lt;/a&gt;，使用ssh连接，编辑 &lt;code&gt;/etc/network/interfaces&lt;/code&gt;，在 &lt;code&gt;auto eth0&lt;/code&gt; 后加上下面的内容：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;iface eth0 inet6 static
        address primary_ipv6_address
        netmask 64
        gateway ipv6_gateway
        autoconf 0
        dns-nameservers 2001:4860:4860::8844 2001:4860:4860::8888 209.244.0.3
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中 &lt;code&gt;primary_ipv6_address&lt;/code&gt; 和 &lt;code&gt;ipv6_gateway&lt;/code&gt; 换成上面那张图里DO分配给你的内容，保存后 &lt;code&gt;service networking restart&lt;/code&gt; 重启网络即可，实在不行重启VPS，可以使用 &lt;code&gt;ifconfig&lt;/code&gt; 来查看是否配置成功。&lt;/p&gt;
&lt;h3 id="vpsshadowsocks"&gt;在VPS上配置Shadowsocks服务&lt;a class="headerlink" href="#vpsshadowsocks" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;在VPS上配置Shadowsocks实质上就是搭建一个SOCKS5服务，在Ubuntu下安装很容易：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;apt-get install python-pip
pip install shadowsocks
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;安装完后还需要对Shadowsocks进行配置，找个地方创建一个配置文件即可，比如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;mkdir /etc/shadowsocks
vim /etc/shadowsocks/config.json
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;配置文件的基本内容：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="nt"&gt;"server"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s2"&gt;"::"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="nt"&gt;"server_port"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;8382&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="nt"&gt;"local_port"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1080&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="nt"&gt;"password"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"yourpassword"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="nt"&gt;"timeout"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;600&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="nt"&gt;"method"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"aes-256-cfb"&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;稍微解释下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;server: 指定SOCKS5服务监听的IP，指定为 &lt;code&gt;::&lt;/code&gt; 的话可以同时监听IPv4及IPv6。&lt;/li&gt;
&lt;li&gt;server_port: 指定监听的端口。&lt;/li&gt;
&lt;li&gt;password: 客户端连接SOCKS5服务时的密码。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;更多的配置可以到&lt;a href="https://shadowsocks.org/en/config/quick-guide.html"&gt;Shadowsocks官网&lt;/a&gt;查看。&lt;/p&gt;
&lt;p&gt;关于服务的启动，ssh连上服务器然后执行下面这个命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# 注意配置文件的路径&lt;/span&gt;
nohup ssserver -c /etc/shadowsocks/config.json &amp;gt;&amp;gt; /var/log/shadowsocks.log&lt;span class="p"&gt;&amp;amp;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;关闭服务的话。。不大优雅：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# 利用lsof通过端口号找到pid&lt;/span&gt;
lsof -i:port
&lt;span class="nb"&gt;kill &lt;/span&gt;xxx
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="shadowsocks"&gt;使用Shadowsocks客户端&lt;a class="headerlink" href="#shadowsocks" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;这里只讲Windows的，OSX上的也基本一样。&lt;/p&gt;
&lt;p&gt;客户端的话到&lt;a href="https://github.com/shadowsocks/"&gt;Github&lt;/a&gt;下载即可，Windows推荐使用&lt;a href="https://github.com/shadowsocks/shadowsocks-windows/releases"&gt;Release&lt;/a&gt;里的2.5.6，亲测比较妥。&lt;/p&gt;
&lt;p&gt;解压后直接启动，在服务器设定里添加服务器即可，填写你在VPS配置的那些内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;VPS IP (v4/v6均可)&lt;/li&gt;
&lt;li&gt;端口、密码、加密方式均按配置文件填&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="_1"&gt;代理模式&lt;a class="headerlink" href="#_1" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Shadowsocks的客户端有两种代理模式：PAC及全局模式。PAC就是只代理部分网站，而全局模式是代理所有的网站。&lt;/p&gt;
&lt;p&gt;Shadowsocks客户端在本机运行了一个代理服务（实测不止SOCKS5，还有HTTP），默认监听端口为1080（可以通过配置修改）。有了代理服务器，剩下的问题就是将需要的流量转向代理。Shadowsocks根据代理模式来判断如何处理流量，PAC模式会根据PAC列表计算是否要代理，全局模式则全部代理，如果确定要代理，就将流量转向 &lt;code&gt;127.0.0.1:1080&lt;/code&gt; 的代理服务，代理服务根据配置连接目标服务器，从而实现科学上网。&lt;/p&gt;
&lt;p&gt;在Windows上，Shadowsocks是通过修改 &lt;code&gt;Internet选项-&amp;gt;连接-&amp;gt;局域网(LAN)设置&lt;/code&gt; 中的内容实现流量转发（至本地代理服务），如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://ww3.sinaimg.cn/large/006y8lVagw1f86x0qp7gfj30cp0c5jst.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;当那个checkbox被勾上的时候，Windows会将它判定的LAN流量都经过Shadowsocks的脚本的过滤，这也就导致，你开启全局模式的时候，一些客户端中的浏览器（如QQ）也会被代理，这一定程度上会影响到使用。建议是不勾上，然后在需要的软件中自行设置HTTP代理。&lt;/p&gt;
&lt;p&gt;比如说，Chrome中可以安装SwitchSharp这样的插件，设置代理服务器地址为 &lt;code&gt;127.0.0.1:1080&lt;/code&gt;，就可以比较灵活地使用Rule来控制代理了。同理，网易云音乐也可以在工具中设置相关的代理服务器，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://ww1.sinaimg.cn/large/006y8lVagw1f86x15ike6j30g308bwep.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;自己可以查看一下使用的软件是否要被代理，比如IDM、迅雷之类的下载软件就可以考虑设置代理。&lt;/p&gt;
&lt;h4 id="ipv6_1"&gt;利用IPv6&lt;a class="headerlink" href="#ipv6_1" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;如果你的运营商支持IPv6的话，建议在客户端配置上增加一个服务器，IP设置为VPS的IPv6 IP。Shadowsocks的服务端程序非常机智，如果你访问的网站是v4站点的话，服务器会在它那边使用v4访问该站，但结果依旧通过v6返回给你。对于校园网用户来说，IPv6一般都是免费的，可以省一笔流量费，并且，v6由于使用人数较少，网络状况也比较好。&lt;/p&gt;
&lt;h3 id="pptp-vpn"&gt;PPTP VPN&lt;a class="headerlink" href="#pptp-vpn" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;这个是额外的，除了在VPS上搭建Shadowsocks服务以外，你还可以自己去做些别的，这里贴个PPTP VPN的&lt;a href="http://blog.kunyu.li/digitalocean-ubuntu-vps-vpn.html"&gt;教程&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id="_2"&gt;参考资料&lt;a class="headerlink" href="#_2" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="https://shadowsocks.org"&gt;Shadowsocks官网&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/shadowsocks/"&gt;Shadowsocks on Github&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.kunyu.li/digitalocean-ubuntu-vps-vpn.html"&gt;PPTP VPN搭建&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.wikiwand.com/en/Proxy_auto-config"&gt;PAC&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</summary><category term="Shadowsocks"></category><category term="VPS"></category><category term="VPN"></category><category term="Ubuntu"></category><category term="DigitalOcean"></category></entry><entry><title>C预处理器宏展开</title><link href="http://goclis.github.io/posts/2016/04/26/c-preprocessor-macro-expansion.html" rel="alternate"></link><updated>2016-04-26T23:21:20+08:00</updated><author><name>Goclis Yao</name></author><id>tag:goclis.github.io,2016-04-26:posts/2016/04/26/c-preprocessor-macro-expansion.html</id><summary type="html">&lt;p&gt;最近在写一个用于简化生成代码的宏，该宏大致希望达到如下功能：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// macro.h&lt;/span&gt;
&lt;span class="cp"&gt;#if defined(T)&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="err"&gt;##&lt;/span&gt; &lt;span class="n"&gt;_func&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="c1"&gt;// ...&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="cp"&gt;#endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这段代码是不能用的，因为预处理符号&lt;code&gt;##&lt;/code&gt;是不能用在代码中的，这里只是用来表示下宏希望实现的目的，即定义一个T，就为之定义一个对应的方法，比如说：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// 这段代码希望定义一个int_func方法&lt;/span&gt;
&lt;span class="cp"&gt;#define T int&lt;/span&gt;
&lt;span class="cp"&gt;#include "macro.h"&lt;/span&gt;
&lt;span class="cp"&gt;#undef T&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面提到了&lt;code&gt;##&lt;/code&gt;是不能直接写在代码里的，所以我一开始是这样实现的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// macro.h&lt;/span&gt;
&lt;span class="cp"&gt;#if defined(T)&lt;/span&gt;
&lt;span class="cp"&gt;#define func_m(TN) TN ## _func&lt;/span&gt;
&lt;span class="cp"&gt;#define T_func func_m(T)&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;T_func&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="c1"&gt;// ...&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="cp"&gt;#endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是，这样的写法并不能够正确的定义我们例子中想要的&lt;code&gt;int_func&lt;/code&gt;方法，而是会定义一个&lt;code&gt;T_func&lt;/code&gt;方法（这一点可以通过查看VS生成的obj文件中的符号确定，或是设置选项让编译器保留预处理产生的.i文件），下面给出正确的写法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// macro.h&lt;/span&gt;
&lt;span class="cp"&gt;#if defined(T)&lt;/span&gt;
&lt;span class="cp"&gt;#define concate(A, B) A ## B&lt;/span&gt;
&lt;span class="cp"&gt;#define func_m(TN) concate(TN, _func)&lt;/span&gt;
&lt;span class="cp"&gt;#define T_func func_m(T)&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;T_func&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="c1"&gt;// ...&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="cp"&gt;#endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;之所以需要这样来实现是因为宏展开的规则，我对于宏展开的规则不是特别熟悉，但在&lt;a href="https://msdn.microsoft.com/zh-cn/library/09dwwt6y.aspx"&gt;MSDN&lt;/a&gt;上找到了一段可能能够用来解释的内容：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果宏定义中的形参的前面或后面带有 token-pasting 运算符，则会立即将形参替换为未扩展的实参。在替换前将不会对参数执行宏扩展。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;token-pasting运算符就是&lt;code&gt;##&lt;/code&gt;。结合我原先的实现以及这段话，当预处理器在处理&lt;code&gt;T_func&lt;/code&gt;时，它会替换为&lt;code&gt;func_m(T)&lt;/code&gt;，这类似于一个函数调用，预处理器查看了一下&lt;code&gt;func_m&lt;/code&gt;这个宏的内容，发现其中有&lt;code&gt;##&lt;/code&gt;符号，所以，它直接将形参（即TN）替换成了未扩展的实参（即T），替换前并没有对T进行宏展开，从而导致无论T是什么，&lt;code&gt;T_func&lt;/code&gt;都是最终结果。
这点通过修改一下代码也可以验证：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#define T_func func_m(B)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里改成了B，所以最后定义的符号是&lt;code&gt;B_func&lt;/code&gt;，因为不管是啥，预处理器都不会对它展开。&lt;/p&gt;
&lt;p&gt;本来想结合生成的obj文件来写的，但写这个的时候不是用的Windows，所以就算了，懒23333。&lt;/p&gt;</summary><category term="预处理器"></category><category term="宏"></category></entry><entry><title>HTTP请求中的数据</title><link href="http://goclis.github.io/posts/2016/04/16/data-in-http-request.html" rel="alternate"></link><updated>2016-04-16T22:47:20+08:00</updated><author><name>Goclis Yao</name></author><id>tag:goclis.github.io,2016-04-16:posts/2016/04/16/data-in-http-request.html</id><summary type="html">
&lt;p&gt;那天在帮同学调代码的时候发现自己对于HTTP Request的细节很模糊，对于各种形式的数据是如何被处理封装成HTTP报文的、在报文中的哪个位置，并不是非常的清楚，因此，查了查资料后写了这篇东西。&lt;/p&gt;
&lt;h3 id="http"&gt;HTTP请求格式&lt;a class="headerlink" href="#http" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;先看看HTTP请求消息的格式 &lt;a href="http://www.tutorialspoint.com/http/http_requests.htm"&gt;1&lt;/a&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A Request Line&lt;/li&gt;
&lt;li&gt;Zero or more header (General|Request|Entity) fields followed by CRLF&lt;/li&gt;
&lt;li&gt;An empty line (i.e., a line with nothing preceding the CRLF) indicating the end of the header fields&lt;/li&gt;
&lt;li&gt;Optionally a message-body&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从格式上来看，除了第三部分，都能够附带用户数据，但一般来说，不会在HTTP头里放数据，而且在第一部分的URL以及第四部分中放数据，下面分别讲一下，主要区分下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Query String&lt;/li&gt;
&lt;li&gt;Form Data&lt;/li&gt;
&lt;li&gt;JSON/File Data&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="query-string"&gt;Query String&lt;a class="headerlink" href="#query-string" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;这个实际上就是HTTP请求消息的第一部分URL中?后面的那部分信息，因此，它与请求的类型无关，只和URL相关，下面是个例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;# 附带数据为name: xxx, age: 18
GET example.com?name=xxx&amp;amp;age=18
POST example.com?name=xxx&amp;amp;age=18
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;用python的requests库来实现这个请求的话就是下面这样：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;requests&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;'example.com'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;params&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;'xxx'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;age&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;18&lt;/span&gt;&lt;span class="p"&gt;})&lt;/span&gt;
&lt;span class="n"&gt;requests&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;post&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;'example.com'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;params&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;'xxx'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;age&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;18&lt;/span&gt;&lt;span class="p"&gt;})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;即这些数据会当做参数被编码到请求的URL中，而服务器端会解析这些参数。&lt;/p&gt;
&lt;h3 id="form-data"&gt;Form Data&lt;a class="headerlink" href="#form-data" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;一般来说，form data是指html中form标签提交的数据：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nt"&gt;&amp;lt;form&lt;/span&gt; &lt;span class="na"&gt;action=&lt;/span&gt;&lt;span class="s"&gt;"xxx"&lt;/span&gt; &lt;span class="na"&gt;method=&lt;/span&gt;&lt;span class="s"&gt;"GET"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;input&lt;/span&gt; &lt;span class="na"&gt;type=&lt;/span&gt;&lt;span class="s"&gt;"text"&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;"first"&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;input&lt;/span&gt; &lt;span class="na"&gt;type=&lt;/span&gt;&lt;span class="s"&gt;"text"&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;"second"&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;input&lt;/span&gt; &lt;span class="na"&gt;type=&lt;/span&gt;&lt;span class="s"&gt;"submit&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/form&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是，form data是放在HTTP请求报文中的哪呢？？这个得看提交的方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GET：会被当做Query String一样处理；&lt;/li&gt;
&lt;li&gt;POST：会放到请求消息的第四部分中，编码方式同Query String。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="json-data"&gt;JSON Data&lt;a class="headerlink" href="#json-data" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;其实这里所描述的情况不仅仅适用于JSON数据，而适用于使用其他类型的数据。对于一开始的Web，Query String和Form Data就基本够用了，但后来Web应用的数据的格式越来越复杂，就需要有一定的扩展。&lt;/p&gt;
&lt;p&gt;扩展很简单，使用HTTP头中的Content-Type来表示附带的数据的类型，并按照类型编码数据，然后放到请求消息的第四部分中。服务端可以根据Content-Type来判断如何数据进行解码，常见的数据类型（实际上就是&lt;a href="http://www.iana.org/assignments/media-types/media-types.xhtml"&gt;Media Type&lt;/a&gt;）有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;text/html&lt;/li&gt;
&lt;li&gt;text/xml&lt;/li&gt;
&lt;li&gt;application/json&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关于JSON的示例，可以查看&lt;a href="http://homakov.blogspot.com/2012/06/x-www-form-urlencoded-vs-json-pros-and.html"&gt;2&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id="_1"&gt;参考资料&lt;a class="headerlink" href="#_1" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://www.tutorialspoint.com/http/http_requests.htm"&gt;HTTP Requests&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://homakov.blogspot.com/2012/06/x-www-form-urlencoded-vs-json-pros-and.html"&gt;x-www-form-urlencoded vs json&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.iana.org/assignments/media-types/media-types.xhtml"&gt;IANA Media Types&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</summary><category term="HTTP请求"></category></entry><entry><title>Openssl-RSA简单使用</title><link href="http://goclis.github.io/posts/2015/09/10/openssl-rsa-basic-use.html" rel="alternate"></link><updated>2015-12-26T00:00:00+08:00</updated><author><name>Goclis Yao</name></author><id>tag:goclis.github.io,2015-09-10:posts/2015/09/10/openssl-rsa-basic-use.html</id><summary type="html">
&lt;p&gt;最近需要用到RSA的一些功能，出于方便，打算直接用openssl，但是在不同平台上使用openssl所需要做的工作还不一样，干脆就记个笔记整理一下。&lt;/p&gt;
&lt;h3 id="windowsvs2013openssl"&gt;Windows下使用VS2013编译openssl源码&lt;a class="headerlink" href="#windowsvs2013openssl" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;源码可以去官网下载，先前下过1.0.2d的源码，但是编译老失败，后面换成1.0.1p的就成功了，原因未知。&lt;/p&gt;
&lt;p&gt;编译需要用到perl，去官网下个ActivePerl就可以了，为了往后在cmd中操作简单，最好安装时勾上加入PATH的选项。&lt;/p&gt;
&lt;p&gt;解压源码包，打开cmd进入该解压后的目录，执行如下命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;perl Configure VC-WIN32 no-asm --prefix=C:\openssl-1.0.1p\VC-WIN32
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是编译前必须执行的配置命令，可以自行根据所使用的编译工具以及平台的不同来选择不同的参数（具体可以查看解压后目录中的README以及一系列的INSTALL文件），稍微解释一下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;VC-WIN32：表示希望使用VS来编译生成WIN32下使用的openssl库，还可以是其他的比如debug-VC-WIN32、VC-WIN64A等等。&lt;/li&gt;
&lt;li&gt;no-asm：表示编译不使用汇编语言文件，这样可以避免出现与NASM相关的错误。&lt;/li&gt;
&lt;li&gt;prefix：此参数后面的值用于指定编译结果的安装目录。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用VS编译会使用到VS的nmake、cl、link等工具，默认情况下这些工具是不在PATH里的，所以正常打开cmd是没法找到这些工具的，解决方案有两个：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;把它们所在的目录加入到PATH环境变量中。在 &lt;code&gt;VS安装目录/VC&lt;/code&gt; 文件夹里有个 &lt;code&gt;vcvarsall.bat&lt;/code&gt; 的脚本，执行这个脚本就可以了。&lt;/li&gt;
&lt;li&gt;使用VS提供的Tools。每个VS基本都提供了相应的命令行工具（从开始菜单里可以找到），启动这些命令行工具后会自动把这些基础工具加入到此次运行的PATH中（实际上它就是运行了1中的脚本，只不过仅在此次cmd中生效）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;简单的配置完毕后开始进行编译。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;静态库&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;ms\do_ms
nmake -f ms\nt.mak
nmake -f ms\nt.mak install
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;动态库&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;ms\do_ms
nmake -f ms\nt.mak
nmake -f ms\nt.mak install
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;install&lt;/code&gt; 表示将生成的内容（头文件及库）安装到使用perl进行配置时指定的目录中。&lt;/p&gt;
&lt;p&gt;就我而言，我需要生成debug及release的库，整个过程如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;perl Configure debug-VC-WIN32 no-asm --prefix=c:\openssl-1.0.1p\debug-VC-WIN32
ms\do_ms
nmake -f ms\nt.mak
nmake -f ms\nt.mak install
perl Configure VC-WIN32 no-asm --prefix=c:\openssl-1.0.1p\VC-WIN32
ms\do_ms
nmake -f ms\nt.mak
nmake -f ms\nt.mak install
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;经过简单的测试，发现使用VS的08、10、13来进行编译产生的内容是一样的。&lt;/p&gt;
&lt;h3 id="linuxopenssl"&gt;Linux下安装openssl库&lt;a class="headerlink" href="#linuxopenssl" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;我的发行版是Ubuntu 14.04，但是默认安装的好像只有一个openssl的可执行程序，没有头文件及库文件，需要另外安装 &lt;code&gt;libssl&lt;/code&gt; ，如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;sudo apt-get install libssl-dev
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在编译你的目标文件时指定 &lt;code&gt;-lssl&lt;/code&gt; 及 &lt;code&gt;-lcrypto&lt;/code&gt; 选项即可使用相关的功能，如果只用到加密库的话，只需要使用后者即可。&lt;/p&gt;
&lt;p&gt;暂时没有去研究如何静态链接openssl。&lt;/p&gt;
&lt;h3 id="openssl"&gt;openssl可执行程序的使用&lt;a class="headerlink" href="#openssl" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;openssl除了提供编程相关的头文件及库文件外，还有一个应用程序直接提供了相关的功能，这里简单的罗列一些。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RSA密钥生成&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用该程序可以直接生成RSA的公私钥：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;openssl genrsa -out private.pem &lt;span class="m"&gt;2048&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; openssl rsa -in private.pem -pubout &amp;gt; public.pem
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是需要注意的是，这里的生成是按照PEM格式进行的，所以如果在编程时需要读取这些文件，要使用PEM相关的API。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;提取RSA公钥内容&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们知道RSA的公钥是由(n,e)组成的，但是openssl生成的公钥为了可读进行了BASE64编码，可以使用如下命令进行提取：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;openssl rsa -pubin -inform PEM -text -noout &amp;lt; public.pem
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="rsa"&gt;RSA相关编程&lt;a class="headerlink" href="#rsa" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;h4 id="rsa_1"&gt;RSA结构体&lt;a class="headerlink" href="#rsa_1" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;RSA结构体在编程中代表RSA的密钥（公钥或私钥），在描述RSA操作之前，先说说RSA的结构体如何构建，也就两种方式：从文件构建或从内存构建。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文件&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;RSA&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nf"&gt;createRSAWithFilename&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;filename&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;isPub&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;BIO&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;in&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;in&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;BIO_new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;BIO_s_file&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;BIO_read_filename&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;in&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;filename&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;BIO_free&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;in&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;RSA&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;rsa&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;isPub&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;rsa&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;PEM_read_bio_RSA_PUBKEY&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;in&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;rsa&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;PEM_read_bio_RSAPrivateKey&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;in&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;BIO_free&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;in&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;rsa&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;稍微注意一下构造公钥的方法是 &lt;code&gt;*_RSA_PUBKEY&lt;/code&gt; 而不是 &lt;code&gt;*_RSAPublicKey&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;PS：对于从文件构建密钥，有一组方法 &lt;code&gt;PEM_read_RSA_PUBKEY&lt;/code&gt; 和 &lt;code&gt;PEM_read_RSAPrivateKey&lt;/code&gt; 可以直接根据打开的文件构建出对应的RSA结构体，但是在Windows上使用前面那个方法的时候，编译通过，但运行时会提示 &lt;code&gt;Openssl Uplink&lt;/code&gt; ，所以改用了openssl内置的BIO。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;内存&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;同样利用BIO，代码类似：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;RSA&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nf"&gt;createRSAWithMemory&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;bufLen&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;isPub&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;BIO&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;in&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;in&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;BIO_new_mem_buf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;bufLen&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;RSA&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;rsa&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;isPub&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;rsa&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;PEM_read_bio_RSA_PUBKEY&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;in&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;rsa&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;PEM_read_bio_RSAPrivateKey&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;in&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;BIO_free&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;in&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;rsa&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="rsa_2"&gt;RSA操作&lt;a class="headerlink" href="#rsa_2" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;RSA的使用包括两种基本情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;公钥加密 &amp;amp; 私钥解密&lt;/li&gt;
&lt;li&gt;私钥签名 &amp;amp; 公钥验签&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下代码省略构造RSA的部分，公钥的RSA为 &lt;code&gt;pubRSA&lt;/code&gt; ，私钥的RSA为 &lt;code&gt;priRSA&lt;/code&gt; ，处理的内容为 &lt;code&gt;content&lt;/code&gt; ，长度为 &lt;code&gt;contentLen&lt;/code&gt; ，忽略一些强制转换。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;公钥加密 &amp;amp; 私钥解密&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;RSA_size&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pubRSA&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;encrypted&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="c1"&gt;// 返回值表示密文的长度，由于Padding，应该等于size&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;ecRet&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;RSA_public_encrypt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;contentLen&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;content&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pubRSA&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;RSA_PKCS1_PADDING&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;ecRet&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// failed&lt;/span&gt;
    &lt;span class="c1"&gt;// ...&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;decrypted&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt; &lt;span class="c1"&gt;// 加密的内容不能超过RSA密钥的长度&lt;/span&gt;
&lt;span class="c1"&gt;// 返回值即原文的长度&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;dcRet&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;RSA_private_decrypt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ecRet&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;encrypted&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;decrypted&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;priRSA&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;RSA_PKCS1_PADDING&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;dcRet&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// failed&lt;/span&gt;
    &lt;span class="c1"&gt;// ...&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;私钥签名 &amp;amp; 公钥验签&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;代码类似，如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;RSA_size&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pubRSA&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;encrypted&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;ecRet&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;RSA_private_encrypt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;contentLen&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;content&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;priRSA&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;RSA_PKCS1_PADDING&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;ecRet&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// failed&lt;/span&gt;
    &lt;span class="c1"&gt;// ...&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;decrypted&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;dcRet&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;RSA_public_decrypt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ecRet&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;encrypted&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;decrypted&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pubRSA&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;RSA_PKCS1_PADDING&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;dcRet&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// failed&lt;/span&gt;
    &lt;span class="c1"&gt;// ...&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="rsa_3"&gt;大数操作替换RSA&lt;a class="headerlink" href="#rsa_3" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;公钥验签&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// 公钥使用(n,e)表示, 验签的内容使用c表示&lt;/span&gt;
&lt;span class="n"&gt;BigInteger&lt;/span&gt; &lt;span class="nf"&gt;n&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nbuf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;nlen&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;BigInteger&lt;/span&gt; &lt;span class="nf"&gt;e&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ebuf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;elen&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;BigInteger&lt;/span&gt; &lt;span class="nf"&gt;c&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cbuf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;clen&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// 结果r&lt;/span&gt;
&lt;span class="n"&gt;BigInteger&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;modpow&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="_1"&gt;参考资料&lt;a class="headerlink" href="#_1" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;http://hayageek.com/rsa-encryption-decryption-openssl-c/&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.csdn.net/rabbit729/article/details/3886984"&gt;Openssl Uplink&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;http://developer.covenanteyes.com/building-openssl-for-visual-studio/&lt;/li&gt;
&lt;li&gt;http://linux.die.net/man/3/bio_new_mem_buf&lt;/li&gt;
&lt;/ol&gt;</summary><category term="Openssl"></category><category term="RSA"></category></entry><entry><title>Data Linker Layer Authentication</title><link href="http://goclis.github.io/posts/2014/08/21/data-linker-layer-authentication.html" rel="alternate"></link><updated>2014-08-21T16:21:00+08:00</updated><author><name>Goclis Yao</name></author><id>tag:goclis.github.io,2014-08-21:posts/2014/08/21/data-linker-layer-authentication.html</id><summary type="html">&lt;p&gt;标题可能不是很准确，这篇东东主要是想研究一下日常的上网中，ISP对我们的用户名和密码的验证的这个过程，发生了一些什么。由于查了不少资料发现这个过程大多是在链路层协议负责的，所以标题就先这样啦@_@。&lt;/p&gt;
&lt;p&gt;下面列举下我自己平常的一些上网方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;宿舍网线拨号&lt;/li&gt;
&lt;li&gt;WIFI + 网页验证&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这两种方式大家都挺常用的，这里只讨论非NAT网络的，也就是你直接连接到ISP而不是通过路由什么的，先说拨号吧。&lt;/p&gt;
&lt;h3 id="_1"&gt;拨号上网&lt;a class="headerlink" href="#_1" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;一般拨号的协议都是PPPoE，全称Point-to-point-on-Ethernet，顾名思义，在以太网上的PPP。PPP本身就是一个链路层的协议，不过我不大清楚用来连接它的线路应该是啥样的，而PPPoE的出现貌似就是为了保证在Ethernet上还能使用PPP的优势，因为Ethernet本身并不是点对对的，PPPoE就弄出了一个virtual point to point，这样，在用户的角度，和ISP之间的关系就好像是点对点了，ISP和用户都挺高兴，所以PPPoE广泛地被ISP们采用。&lt;/p&gt;
&lt;p&gt;以下为个人猜想，错误请指出，谢谢！&lt;/p&gt;
&lt;p&gt;先来看看一般的ISP架构， ISP的每一个组成可能都不止一台主机 ：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://ww2.sinaimg.cn/large/006y8lVagw1f86y4uft4tj30p90fon0o.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;接下来就按照这个图来讲讲整个拨号的过程吧。&lt;/p&gt;
&lt;h4 id="1"&gt;1. 插上网线&lt;a class="headerlink" href="#1" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;插上网线后，你应该只能访问ISP架构中的有限内容，准确来说，你应该只能访问用户认证这个部分，其他部分对你来说都是不通的。&lt;/p&gt;
&lt;h4 id="2"&gt;2. 拨号认证&lt;a class="headerlink" href="#2" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;这里以PPPoE为例，但协议本身的内容不少，只粗略讲下过程，下面这段内容摘自&lt;a href="http://baike.baidu.com/view/3246.htm#2_2"&gt;百度百科&lt;/a&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在STA和AP之间建立好关联之后，客户端向AC设备发送一个PADI报文，开始PPPOE接入的开始。&lt;/li&gt;
&lt;li&gt;AC向客户端发送PADO报文。&lt;/li&gt;
&lt;li&gt;客户端根据回应，发起PADR请求给AC。&lt;/li&gt;
&lt;li&gt;Ac产生一个session id，通过PADS发给客户端。&lt;/li&gt;
&lt;li&gt;客户端和AC之间进行PPP的LCP协商，建立链路层通信。同时，协商使用PAP、CHAP认证方式。&lt;/li&gt;
&lt;li&gt;AC通过Challenge报文发送给认证客户端，提供一个128bit的Challenge。&lt;/li&gt;
&lt;li&gt;客户端收到Challenge报文后，将密码和Challenge做MD5算法后的Challenge—Password，在Response回应报文中把它发送给AC设备。&lt;/li&gt;
&lt;li&gt;Ac将Challenge、challenge-Password和用户名一起送到RADIUS用户认证服务器，由RADIUS用户认证服务器进行认证。&lt;/li&gt;
&lt;li&gt;RADIUS用户认证服务器根据用户信息判断用户是否合法，然后回应认证成功/失败报文到AC。如果成功，携带协商参数，以及用户的相关业务属性给用户授权。如果认证失败，则流程到此结束。&lt;/li&gt;
&lt;li&gt;AC将认证结果返回给客户端。&lt;/li&gt;
&lt;li&gt;用户进行NCP(如IPCP)协商，通过AC获取到规划的IP地址等参数。&lt;/li&gt;
&lt;li&gt;认证如果成功，AC发起计费开始请求给RADIUS用户认证服务器。&lt;/li&gt;
&lt;li&gt;RADIUS用户认证服务器回应计费开始请求报文。用户上线完毕，开始上网。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其中，第5步协商的认证方式因协商双方不同而不同，往后的认证过程也因协商的认证方式不同而不同。&lt;/p&gt;
&lt;p&gt;经过上面这个过程，在ISP那边就已经将你的用户名注册上网了，并且，它会为你的机器分配好IP地址，DNS服务器等参数。&lt;/p&gt;
&lt;p&gt;之前，我对认证这块有着一个很大的疑问：ISP是如何确定一个数据帧是否应该转发，即ISP怎么知道这个数据帧是否来自于一个已经通过验证了的主机？&lt;/p&gt;
&lt;p&gt;这个问题并不属于协议内容，协议选择了将这个问题交给ISP去实现，我个人的猜想是通过记录MAC地址。
在用户认证成功后，ISP会将你的主机的MAC地址记录为可放行的，当一个帧到来的时候，它就会检查该帧的Source MAC Address是否是可放行的，如果是的话，就放行。当然， 这就要求和你机器直接相连的那台ISP设备有着区分这个的能力，因为如果经过那台设备，Source MAC Address就会换成它的了。&lt;/p&gt;
&lt;h4 id="3"&gt;3. 上网&lt;a class="headerlink" href="#3" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;经过1和2两步后，就可以上网了，数据包的分发大致如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;上层数据构成IP Packet，传递到链路层。&lt;/li&gt;
&lt;li&gt;链路层加上Header和Trailer，Header里的Source MAC Address是本机的MAC地址，Destination MAC Address为直接相连的那台Switch。&lt;/li&gt;
&lt;li&gt;数据帧到达Switch，Switch检查Source MAC Address是否可放行，不可放行则丢弃帧，否则放行。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;上面这3步基本上就是数据帧通过的过程，而数据帧能否通过，就是是否进行了用户认证的事了，其他的，DNS什么的事都是基于这个基础的。&lt;/p&gt;
&lt;h3 id="wifi"&gt;Wifi上网&lt;a class="headerlink" href="#wifi" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;学校的校园wifi的认证则要比拨号认证多一层。&lt;/p&gt;
&lt;p&gt;首先，要连上AP，这个的认证的作用和拨号的用户认证相似，经过了这一层认证后才能保证你的数据帧能被AP转发出去，而学校的server，从校园网的记录上来看，很明显，它保存了你的MAC地址和分配的IP地址的映射。AP具体的认证过程参见802.11。&lt;/p&gt;
&lt;p&gt;其次，在连接上AP后，我们已经可以上内网了，也就意味着，我们的数据包已经可以在内网中转发了，但是，依旧不可以访问外网。我个人的猜想是外网出口的路由那块把出境的数据包给丢弃了，而丢弃的原因，是因为没经过WIFI验证。所以，下一步我们得打开浏览器登陆网址进行WIFI认证。&lt;/p&gt;
&lt;p&gt;而Wifi验证过后，我们的数据包就可以出境访问外网了。所以，这个Wifi验证实际上可能在出口的路由上保存了一组能够出境的IP地址，当数据包到来时，检查它的Source IP，以判断是否放行出境，或者是丢弃。这也就是有一段时间，我们一连上wifi不经过验证就能上网的原因，因为我们被分配到了一个别人已经认证的IP了，而服务器那边还没把这个下线的认证记录给注销掉。&lt;/p&gt;
&lt;h3 id="fix-problems"&gt;Fix Problems&lt;a class="headerlink" href="#fix-problems" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;现在，可以稍微解释下我在&lt;a href="/articles/pptp-vpn-process.html"&gt;PPTP VPN Process&lt;/a&gt;留下的问题了。&lt;/p&gt;
&lt;p&gt;第一个问题这篇东东已经解释的差不多了。&lt;/p&gt;
&lt;p&gt;第二个的话，个人认为，服务器肯定是有一组key-value的映射保存了这些的，而数据包中的信息是足够组成唯一的key的，key由什么组成那就是VPN提供商自己决定的了。&lt;/p&gt;
&lt;h3 id="reference"&gt;Reference&lt;a class="headerlink" href="#reference" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://baike.baidu.com/view/3246.htm#2_2"&gt;PPPoE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://whatismyipaddress.com/ppp-pppoe"&gt;What is PPP and PPPoE?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary><category term="PPPoE"></category><category term="ISP"></category></entry><entry><title>PPTP VPN Process</title><link href="http://goclis.github.io/posts/2014/08/19/pptp-vpn-process.html" rel="alternate"></link><updated>2014-08-19T14:41:00+08:00</updated><author><name>Goclis Yao</name></author><id>tag:goclis.github.io,2014-08-19:posts/2014/08/19/pptp-vpn-process.html</id><summary type="html">
&lt;p&gt;不久前因为StackOverflow上不去的缘故，找人借了下云梯VPN来用了一下，感觉很爽！ 但是自己脑抽，随之而来的伴随了一个问题，云梯VPN的限制设备数量能否区分同一个私有网络下的不同设备，是如何区分的？ 于是乎，就开始去各种找PPTP VPN的资料了，终于有点搞懂了，就通过这篇博文记下来吧。&lt;/p&gt;
&lt;p&gt;以下文章中VPN如不特指皆为PPTP VPN。&lt;/p&gt;
&lt;p&gt;首先找了个免费的VPN试了下，确认了在同一私有网络下不同设备用同一账号是可以连接上同一台VPN Server的，如果不能的话，我的问题也就没啥意义了。虽然这问题确实没啥意义，私有网络要实现共享VPN可以在出口的机器或者路由上建立Site to Site VPN就可以了，但是纯粹好奇，勿喷。。。&lt;/p&gt;
&lt;p&gt;以前只是大概了解了一下VPN的原理，也没有去细究到协议的层次，这次就借着这个机会去好好了解了一下。&lt;/p&gt;
&lt;h3 id="vpn"&gt;VPN的两种架构&lt;a class="headerlink" href="#vpn" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Remote access VPN&lt;/li&gt;
&lt;li&gt;Site-to-site VPN&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Remote access VPN是我们平时个人用的比较多的那种，也就是你在网上买了个VPN，然后拿着账号密码和服务器名连接上了的种，这种就只能保证你自己的那台设备是连上VPN的，而Site-to-site VPN则更像是，如果你用了路由这样的设备，在该设备上拨了VPN，这样路由的私有网络就是一个Site，而路由连上的VPN服务器又构成了另外一个Site，所以是Site-to-site，这种方式就能保证你私有网络中的所有设备都连上了VPN。&lt;/p&gt;
&lt;p&gt;个人感觉，这两种其实差不多算是一种情况吧，只是因为现在的交换设备越来越牛逼了，Site to Site VPN站在路由的角度来看其实就是Remote access VPN了。&lt;/p&gt;
&lt;h3 id="vpn_1"&gt;两种使用VPN的情境&lt;a class="headerlink" href="#vpn_1" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Internet&lt;/li&gt;
&lt;li&gt;Intranet&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本来VPN不是个科学上网的工具的，纯粹就是为了满足在划分了私有网络后又能保证某些有特权的人能访问私有网络的资源，但是，总归是被发掘成了科学上网的工具了。纯吐槽，下面将正事。&lt;/p&gt;
&lt;p&gt;这两种情境的区别就在于一个是在公开的互联网（Internet），而另一个则是在一个机构比如公司的大网络环境中（Intranet），接下来分别说说。&lt;/p&gt;
&lt;h4 id="internet-based-vpn"&gt;Internet-Based VPN&lt;a class="headerlink" href="#internet-based-vpn" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;这一般是一种公司有个内部网络，而你现在的设备不在公司的网络里，比如说在家或者说外地出差，但是这时候你又想要使用公司内网的一些资源，那就得在Internet上使用Remote access VPN或者Site-to-site VPN来保证你能访问公司内网的资源了，所以这种方式是Internet-Based的了，当然，你得连上Internet，并且可以连接上那台公司内网对外的 VPN 服务器。&lt;/p&gt;
&lt;h4 id="intranet-based-vpn"&gt;Intranet-Based VPN&lt;a class="headerlink" href="#intranet-based-vpn" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;这种情况一般用在一个大的私有网络之中，比如你的公司非常大，各个部门在同属于这一个大私有网络的前提下，又各自有着自己的内部私有网络，并且它们为了保证资源的保密性，将这一个个小的私有网络都在物理上隔离了，也就是一个人在没有权限的时候是无法访问另外一个部门的内部资源的。但是，老板所在的那个私有网络可能需要查看各个部门的情况，也就需要访问它们的内部资源，这种时候，类似于Internet-Based那样使用VPN进行即可。&lt;/p&gt;
&lt;h3 id="vpn-tunneling"&gt;VPN Tunneling（隧道）&lt;a class="headerlink" href="#vpn-tunneling" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;隧道是一种常用的网络技巧，目的在于在一个协议的数据报部分封装另一个协议的数据包，即datagram is a packet of anther type of protocol，数据报数据包傻傻分不清囧。&lt;/p&gt;
&lt;p&gt;而VPN也就是使用了这样的技巧，把VPN协议的数据包当做数据报放到了IP包中，这样IP包像正常的数据包一样路由到对端就好了，然后对端通过IP包的IP Header中的协议是能够判断出包含的数据报是使用了某种VPN协议的，于是，对端就按那个协议处理，获取到了真正的数据报。&lt;/p&gt;
&lt;p&gt;这里只是模糊的讲一下大概的过程，这也是我先前对VPN的理解程度，下面从数据包的程度来理解一下，以最简单的PPTP VPN为例了。&lt;/p&gt;
&lt;p&gt;隧道的两端在连接建立的时候需要协商一系列配置变量：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;地址分配（address assignment）&lt;/li&gt;
&lt;li&gt;加密（encryption）&lt;/li&gt;
&lt;li&gt;压缩参数（compression parameters）&lt;/li&gt;
&lt;li&gt;更多&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="point-to-point-tunneling-protocol-pptp"&gt;Point-to-Point Tunneling Protocol (PPTP)&lt;a class="headerlink" href="#point-to-point-tunneling-protocol-pptp" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;看英文全称就可以看出来，PPTP VPN本质上就是基于PPP的Tunneling，所以我们按照之前对隧道的描述，并结合这个协议是个二层协议可以大致猜想下它做的工作了：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一个来自用户的TCP/IP包，下送到PPTP所在的第二层，交由PPTP协议进行处理。&lt;/li&gt;
&lt;li&gt;PPTP协议对这个数据包做了点处理，即加上PPP Header和GRE Header，这个待会再说，然后转交给TCP/IP 层，准确来说是IP层。&lt;/li&gt;
&lt;li&gt;IP层把来自PPTP处理后的这个东西当做数据报，再次加上IPHeader，这个IP Header的参数很重要，下面说，然后该把这个IP包发出去了，所以转交给二层。&lt;/li&gt;
&lt;li&gt;链路层会把这个IP包当做正常的数据包，加上头尾封成帧，丢给物理层发出去了，到此Over。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;上面的这个工作过程讲得很粗糙，但大概就是这么个过程，下面讲的细致一些。&lt;/p&gt;
&lt;h4 id="pptp-inherit-ppp"&gt;PPTP inherit PPP&lt;a class="headerlink" href="#pptp-inherit-ppp" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;Authentication that occurs during the creation of a PPTP-based VPN connection uses the same authentication mechanisms as PPP connections, such as Extensible Authentication Protocol (EAP), Microsoft Challenge-Handshake Authentication Protocol (MS-CHAP), Microsoft Challenge-Handshake Authentication Protocol version 2 (MS-CHAP v2), CHAP, Shiva Password Authentication Protocol (SPAP), and Password Authentication Protocol (PAP). PPTP inherits encryption, compression, or both of PPP payloads from PPP. For PPTP connections, EAP-Transport Layer Security (EAP-TLS), MS-CHAP, or MS-CHAP v2 must be used for the PPP payloads to be encrypted using Microsoft Point-to-Point Encryption (MPPE).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面这段引用很好的诠释了标题，即PPTP直接使用了很大一部分属于PPP的东西，比如加密、压缩等等。&lt;/p&gt;
&lt;h4 id="pptp-control-connection"&gt;PPTP Control Connection&lt;a class="headerlink" href="#pptp-control-connection" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;PPTP毕竟不是PPP那般简单，它最基础的工作就在于它得维护一个隧道，这就是PPTP Control Connection去协商的了，具体的过程参考 &lt;a href="http://tools.ietf.org/html/rfc2637"&gt;RFC 2637&lt;/a&gt;（我怎么没找到要协商的参数囧）。&lt;/p&gt;
&lt;p&gt;&lt;img alt="PPTP Control Connection Packet" src="http://i.technet.microsoft.com/dynimg/IC196814.gif"/&gt;&lt;/p&gt;
&lt;h4 id="pptp-data-tunneling"&gt;PPTP Data Tunneling&lt;a class="headerlink" href="#pptp-data-tunneling" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;这是在使用PPTP Control Connection建立起连接后用来传送数据的，数据包格式如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="Tunneled PPTP Data" src="http://i.technet.microsoft.com/dynimg/IC196815.gif"/&gt;&lt;/p&gt;
&lt;h4 id="pptp-vpn"&gt;PPTP VPN 连接过程&lt;a class="headerlink" href="#pptp-vpn" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;我打算以Windows的PPTP VPN连接的建立过程作为参照，也就是网络连接那，点击一个PPTP VPN，然后输入用户名密码，连接的那个过程，通过wireshark辅助抓包来分析分析。 我尽量讲的细致，因为我自己在去分析的时候遇到了好多自己以前都没有考虑过的问题，比如PPP Authentication，PPP Configuration之类很多的地方，这些都很重要，因为PPTP VPN直接就是继承自PPP，不理解那些根本没法继续较细地分析。&lt;/p&gt;
&lt;p&gt;这个问题是链路层的协议问题，与这儿关系不大，先抛开，下面开始描述整个连接过程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Pharse 1. 确定VPN Server可达，且支持PPTP
创建一个TCP连接，请求连接VPN Server的1723端口（PPTP的端口），三次握手，失败就Over，成功进入下一步。&lt;/li&gt;
&lt;li&gt;Pharse 2. PPTP Control Connection。PPTP Control有着一系列的Message，需要依次确认，其中很关键的步骤为Set-Link-Info，这个步骤需要协商一系列的参数，如身份验证协议等等。但正如之前提及的，PPTP使用的这些实际上是PPP的，所以这个过程和PPP的连接过程类似，单处放于Pharse 3。&lt;/li&gt;
&lt;li&gt;Pharse 3. PPP Configuration。这个其实是属于Set-Link-Info中的一步，本质上就是PPP Link Negotiation with LCP， 这个过程大致就是设置一系列PPP的参数，比如说用什么协议来进行身份验证，乃至加密协议等等。 参考文章中有较为详细的过程。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;整个连接过程执行完后，一系列的参数也就大概协商完毕了，接下来讲讲传输数据的过程。&lt;/p&gt;
&lt;h4 id="pptp-vpn-data-transfer-process"&gt;PPTP VPN Data Transfer Process&lt;a class="headerlink" href="#pptp-vpn-data-transfer-process" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;数据包的格式在PPTP Data Tunneling那给出过，现在按照那个格式，走一遍封装过程，以下建立在PPTP VPN连接已建立的基础上：&lt;/p&gt;
&lt;p&gt;发送方：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;PPTP在第二层收到一个IP数据包，它使用建立过程时协商的参数对IP包进行加密等处理，得到Encrypted PPP Payload，然后加上PPP Header，构成PPP packet。&lt;/li&gt;
&lt;li&gt;添加上GRE Header，GRE Header中的协议类型为PPP (0x880b)，构成GRE packet，然后转交给TCP/IP栈。&lt;/li&gt;
&lt;li&gt;TCP/IP栈根据机器的IP地址，VPN Server的IP地址，把GRE packet当成payload后，新增一个IP Header，IP Header的协议类型为GRE (47)。至此，新的IP packet生成完毕，交由链路层往外发。&lt;/li&gt;
&lt;li&gt;链路层加上头和尾构成帧，外发。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;接收方：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;拿到一个在发送方第三步结束后生成的IP packet，发现IP Header中协议为GRE，所以内部是个GRE packet。&lt;/li&gt;
&lt;li&gt;处理GRE Packet，发现GRE Header的协议是PPP，所以内部是个PPP packet。&lt;/li&gt;
&lt;li&gt;PPP反操作，拿到内部的IP包，重新分发出去，往后该包和正常路由没啥区别。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="vpn_2"&gt;云梯VPN区分设备&lt;a class="headerlink" href="#vpn_2" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;回归到一开始的问题，可以发现，整个过程中有着不少的地方能用来让VPN Server限制一个账号密码的同时使用设备数，下面是我的一些猜想，可能实际中并不会用到。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在PPTP VPN登录的时候是需要验证用户名和密码的，或许这个时候Server就可以认为有一台设备登录了。&lt;/li&gt;
&lt;li&gt;非NAT网络下，IP进行区分。&lt;/li&gt;
&lt;li&gt;NAT网络下，GRE Header中有一个字段将会替换成Port，这个可以区分。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;2和3我并不是很确定，因为有些问题我还没搞清楚，有空的话研究一下，下一篇讲吧。&lt;/p&gt;
&lt;h3 id="problems"&gt;Problems&lt;a class="headerlink" href="#problems" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;上面描述的过程中，有很多细节都没有具体的讲，尤其是关于PPP的加密之类的，原因是个人也没了解过链路层的协议，对这方面也很晕，打算接下来要补补，下面有一些遗留的问题，可能很蠢但是还是得解决呀，先把工作搞定囧。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我们平常在连接 Internet 的时候，总会有输入账号密码进行身份验证的环节，验证的环节究竟做了些什么？验证过后，协议又是如何保证往后的数据包（或许该是帧）是经过验证的呢？？&lt;/li&gt;
&lt;li&gt;一台PPTP VPN Server是可以服务于多台机器的，那么，在接收的第三个步骤拿到的PPP包，服务器是如何知道该用哪个密钥或什么参数去反操作这个包（每个用户怎么可能都协商出相同的参数呢！）？&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="_1"&gt;总结&lt;a class="headerlink" href="#_1" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;微软TechNet的科普文业界良心，Reference值得一看！&lt;/p&gt;
&lt;h3 id="references"&gt;References&lt;a class="headerlink" href="#references" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://tools.ietf.org/html/rfc2637"&gt;RFC 2637&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://technet.microsoft.com/en-us/library/cc958006.aspx"&gt;PPP Connection Process&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://technet.microsoft.com/zh-cn/library/cc779919(v=ws.10).aspx"&gt;How VPN Works: Virtual Private Network (VPN)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://technet.microsoft.com/en-us/library/cc957992.aspx"&gt; PPP Link Negotiation with LCP&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</summary><category term="VPN"></category><category term="PPTP"></category></entry><entry><title>mov指令与内存</title><link href="http://goclis.github.io/posts/2014/08/08/mov-with-memory.html" rel="alternate"></link><updated>2014-08-08T16:00:00+08:00</updated><author><name>Goclis Yao</name></author><id>tag:goclis.github.io,2014-08-08:posts/2014/08/08/mov-with-memory.html</id><summary type="html">&lt;p&gt;今天在啃《深入理解计算机系统》的时候遇到了下面这段代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nf"&gt;movl&lt;/span&gt; &lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;%ebp&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="nv"&gt;%eax&lt;/span&gt;
&lt;span class="nf"&gt;imull&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;%ebp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nf"&gt;movl&lt;/span&gt; &lt;span class="nv"&gt;%eax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;%esp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nf"&gt;movl&lt;/span&gt; &lt;span class="nv"&gt;%edx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;%esp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码的作用就是将两个数的乘积存回栈顶。代码没有问题，让我疑惑的是书上这两句话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;存储两个寄存器的位置对小端机器来说是对的——寄存器 %edx 中的高位存在相对于 %eax 的低位偏移量为 4 的地方。
栈是向低地址方向增长的，也就是说低位在栈顶。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在考虑这两句话的时候，突然发现自己对 mov 的操作并不是特别的清楚，就去查了查，大致搞明白了一些。&lt;/p&gt;
&lt;h3 id="mov"&gt;mov指令&lt;a class="headerlink" href="#mov" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;我们知道 mov 在 IA32 中有基础的三类操作，即 b，w，l。
而 mov 在使用时大致如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nf"&gt;movb&lt;/span&gt; &lt;span class="nv"&gt;%al&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;%edx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c"&gt;# 将 al 寄存器的内容放到以 %edx 的值为地址的内存区域&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里因为是 b 类型的，只有一个字节，所以直接将该字节放到那个地址对应的地方即可。然而对于 w 和 l，源不止一个字节，这个时候，一个内存地址只能表示存放开始的地方，想要存储源操作数，需要多个地址，表达可能不清楚，用代码来说明：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nf"&gt;movl&lt;/span&gt; &lt;span class="nv"&gt;%eax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;%edx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们知道内存是按字节整理的，也就是说 edx 代表的那个地址也就只有 1 个字节，而源操作数 eax 却是 4 个字节，因而，需要多个地址进行存放，我们假设下 %eax = 0x0A0B0C0D，%edx = 4，则内存图如下表：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;地址&lt;/th&gt;
&lt;th&gt;内容&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;0D&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;0C&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;0B&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;0A&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;这里是假设机器为&lt;strong&gt;小端&lt;/strong&gt;。可见，占用了 4~7 的内存地址。所以，mov 指令实际占用内存地址的情况是与源操作数的字节数有关的，而多出来的地方，是通过开始地址（即指令中的目标操作数）往上加的。&lt;/p&gt;
&lt;h3 id="_1"&gt;回归问题&lt;a class="headerlink" href="#_1" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;既然知道了 mov 的行为，再回过头来看看那段代码。假设乘积为 0x010203040A0B0C0D，%esp = 104，小端机器，则该段代码执行后内存应该是如下这样的：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;地址&lt;/th&gt;
&lt;th&gt;0-7&lt;/th&gt;
&lt;th&gt;8-15&lt;/th&gt;
&lt;th&gt;16-23&lt;/th&gt;
&lt;th&gt;24-31&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;td&gt;..&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;104&lt;/td&gt;
&lt;td&gt;0D&lt;/td&gt;
&lt;td&gt;0B&lt;/td&gt;
&lt;td&gt;0C&lt;/td&gt;
&lt;td&gt;0A&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;108&lt;/td&gt;
&lt;td&gt;04&lt;/td&gt;
&lt;td&gt;03&lt;/td&gt;
&lt;td&gt;02&lt;/td&gt;
&lt;td&gt;01&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;很明显了，低位 (0D) 在 栈顶 (104)，这就解释了：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;栈是向低地址方向增长的，也就是说低位在栈顶。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但是。。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;%edx 的高位存在相对于 %eax 的低位偏移量为 4 的地方&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这句话还是没法解释。。%edx 的高位 (01) 相对于 %eax 的低位 (0D)，偏移量好像不是 4 啊。。&lt;/p&gt;</summary><category term="汇编"></category></entry><entry><title>操作系统课设笔记</title><link href="http://goclis.github.io/posts/2014/07/30/os-experiment-note.html" rel="alternate"></link><updated>2014-07-30T17:22:00+08:00</updated><author><name>Goclis Yao</name></author><id>tag:goclis.github.io,2014-07-30:posts/2014/07/30/os-experiment-note.html</id><summary type="html">
&lt;p&gt;因为实习，没法一次性把课设做完，就干脆些把笔记写成博文方便自己查阅吧，持续更新，直至完成。&lt;/p&gt;
&lt;p&gt;这课设的设计基本上是依赖于一本书的，大概是怕我们遇到太多的坑吧。。而OS上的坑又不是那么容易解决的，总之以下操作不带有普遍性。&lt;/p&gt;
&lt;p&gt;课设平台：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;fedora 7&lt;/li&gt;
&lt;li&gt;linux-2.6.21 source code&lt;/li&gt;
&lt;li&gt;i386&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="1"&gt;实验1 编译内核&lt;a class="headerlink" href="#1" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;纯粹照着书搞。。&lt;/p&gt;
&lt;h4 id="_1"&gt;实验过程&lt;a class="headerlink" href="#_1" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;以下操作假设用户为root，目录自行决定。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;% tar -zxvf linux-2.6.21.tar.gz
% &lt;span class="nb"&gt;cd &lt;/span&gt;linux-2.6.21
% make mrproper  &lt;span class="c"&gt;# 清楚掉之前编译产生的垃圾&lt;/span&gt;
% make oldconfig  &lt;span class="c"&gt;# 如果自己有配置文件的话，直接 copy 进来命名为 .config 即可&lt;/span&gt;
% vim Makefile
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改&lt;code&gt;EXTARVERSION =&lt;/code&gt;，改为&lt;code&gt;EXTRAVERSION = .7-custom-version&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这样的话你生成的内核版本号就为2.6.21.7-custom-version（前面有几个参数是指定 2,6,21 的，这里没给出），继续：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;% make all
% make modules_install
% make install
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样的话新的内核就已经更新到了/boot下，并且grub的配置文件（/etc/grub.conf）也已经被更新了。&lt;/p&gt;
&lt;p&gt;有兴趣研究的同学可以继续去查看terminal给出的那个sh命令之后的那个文件，进而会跟到另外一个文件里面，我只是粗略看了下没有深究，就不多说了。&lt;/p&gt;
&lt;p&gt;最后一步reboot，就可以看到在grub的选项中看到你的内核了（.7-custom-version结尾的那个）。&lt;/p&gt;
&lt;h3 id="2"&gt;实验2 系统调用&lt;a class="headerlink" href="#2" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;这里只是添加一个最简单的系统调用，无参数，无实际操作！加复杂的系统调用的时候可能会遇到各种坑，在做往后几个实验的时候再去解决吧。&lt;/p&gt;
&lt;h4 id="_2"&gt;实验过程&lt;a class="headerlink" href="#_2" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;假设要添加的系统调用名为goclis，则内核对应的实现函数名一般为&lt;code&gt;sys_goclis&lt;/code&gt;，现在开始实现。目录和用户假设同实验1。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;% &lt;span class="nb"&gt;cd &lt;/span&gt;linux-2.6.21
% vim arch/i386/kernel/syscall_table.S
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;往系统调用表的末尾添加要新增的系统调用：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="na"&gt;.long&lt;/span&gt; &lt;span class="no"&gt;sys_tee&lt;/span&gt;       &lt;span class="err"&gt;/&lt;/span&gt;&lt;span class="p"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;315&lt;/span&gt; &lt;span class="p"&gt;*&lt;/span&gt;&lt;span class="err"&gt;/&lt;/span&gt;
&lt;span class="na"&gt;.long&lt;/span&gt; &lt;span class="no"&gt;sys_vmsplice&lt;/span&gt;
&lt;span class="c"&gt;# 省略几个。。&lt;/span&gt;

&lt;span class="na"&gt;.long&lt;/span&gt; &lt;span class="no"&gt;sys_goclis&lt;/span&gt;    &lt;span class="err"&gt;/&lt;/span&gt;&lt;span class="p"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;320&lt;/span&gt; &lt;span class="p"&gt;*&lt;/span&gt;&lt;span class="err"&gt;/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;添加头文件goclis.h（这里其实非必要）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;% vim include/linux/goclis.h
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;正如我所说，这个系统调用非常简单，所以。。头文件除了宏保护就是空：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// goclis.h&lt;/span&gt;

&lt;span class="cp"&gt;#ifndef _LINUX_GOCLIS_H&lt;/span&gt;
&lt;span class="cp"&gt;#define _LINUX_GOCLIS_H&lt;/span&gt;

&lt;span class="cp"&gt;#endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;添加实现文件goclis.c，在里面要加入我们指定的系统调用的实现，宏&lt;code&gt;asmlinkage&lt;/code&gt;表示该函数的参数通过栈传递：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;vim&lt;/span&gt; &lt;span class="n"&gt;kernel&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;goclis&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;

&lt;span class="c1"&gt;// goclis.c&lt;/span&gt;

&lt;span class="cp"&gt;#include &amp;lt;linux/linkage.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;linux/goclis.h&amp;gt;&lt;/span&gt;

&lt;span class="n"&gt;asmlinkage&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;sys_goclis&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;320&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;// 这个是随意的&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;实现很简单的系统调用，继续，为该系统调用添加支持：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;vim kernel/Makefile
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;找到如下内容：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;obj-y = sched.o fork.o exec_domain.o \
        ...
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;加入goclis.o：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;obj-y = goclis.o sched.o ...
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样才能保证goclis.c在内核编译链接的时候是可见的。但其实这个调用的实现也不一定要写在goclis.c中，完全可以放在一个已经存在的.c中即可，只要保证这个.c对应的.o能被编译链接。&lt;/p&gt;
&lt;p&gt;接着为这个系统调用定义系统调用，我们之前那个320只是个注释：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;% vim include/asm-i386/unistd.h
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;是i386不是ia64，因为我们是32位的系统。接着找到：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#define __NR_epoll_wait     319&lt;/span&gt;

&lt;span class="cp"&gt;#ifdef __KERNEL__&lt;/span&gt;

&lt;span class="cp"&gt;#define NR_syscalls         320&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#define __NR_epoll_wait     319&lt;/span&gt;
&lt;span class="cp"&gt;#define __NR_goclis         320&lt;/span&gt;

&lt;span class="cp"&gt;#ifdef __KERNEL__&lt;/span&gt;

&lt;span class="cp"&gt;#define NR_syscalls         321&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;很显然吧，用&lt;code&gt;__NR_goclis&lt;/code&gt;来命名我们的系统调用，然后把它定义为320，这样就真的 320了。。&lt;/p&gt;
&lt;p&gt;最后，还得把你的这个系统调用加入到统一的系统调用头文件中：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;% vim include/linux/syscalls.h
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;加入头文件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;linux/goclis.h&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;加入声明：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;asmlinkage&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;sys_goclis&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;OK，重新编译内核然后reboot，就ok了！&lt;/p&gt;
&lt;p&gt;关于编译内核，因为之前已经编译过产生了很多的.o 了，节省时间的话，直接make就可以接着编译了，否则重头编译超级浪费时间。。&lt;/p&gt;
&lt;p&gt;重启后测试下我们的系统调用是否生效，注意得重启为我们创的这个内核！&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// test.c&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;sys/syscall.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;unistd.h&amp;gt;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;ret&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;syscall&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;320&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"%d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ret&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;编译后运行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;% gcc test.c
% ./a.out

320
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ok~，打印出 320 了。&lt;/p&gt;
&lt;h3 id="3"&gt;实验3 进程隐藏&lt;a class="headerlink" href="#3" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;实验的本质目的应该是修改一系列与/proc目录相关的方法，从而实现“隐藏”的要求。&lt;/p&gt;
&lt;h4 id="_3"&gt;思路分析&lt;a class="headerlink" href="#_3" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;ls /proc及ps aux引起的系统调用层次如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;% ls /proc (or ps aux)&lt;/span&gt;
&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;proc_root_readdir&lt;/span&gt;
    &lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;proc_readdir&lt;/span&gt;
    &lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;proc_pid_readdir&lt;/span&gt;
        &lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;proc_base_fill_cache&lt;/span&gt;
        &lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;proc_pid_fill_cache&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中，&lt;code&gt;proc_base_fill_cache&lt;/code&gt;和&lt;code&gt;proc_pid_fill_cache&lt;/code&gt;会将进程标识写入用户缓冲区中。因此，实验的关键就在于要过滤掉那些隐藏的进程，不让它们调用这些方法，这个通过修改其上层的方法&lt;code&gt;proc_pid_readdir&lt;/code&gt;可以做到。&lt;/p&gt;
&lt;p&gt;其他的功能的实现方式其实类似于ls /proc隐藏进程的实现：大致就是用户通过系统调用，修改了相应的&lt;code&gt;task_struct&lt;/code&gt;内部的值，然后修改proc文件系统的一些方法，使得它们根据&lt;code&gt;task_struct&lt;/code&gt;中的值的不同，产生不同的行为即可。&lt;/p&gt;
&lt;p&gt;现在来大致分析下实验需要实现什么：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;添加两个系统调用：&lt;code&gt;asmlinkage int sys_hide(pid_t pid, int on)&lt;/code&gt;和&lt;code&gt;asmlinkage int sys_hide_user_process(uid_t uid, char *binname)&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;修改task_struct的结构，添加支持隐藏的信息。&lt;/li&gt;
&lt;li&gt;修改proc文件系统的一些方法：如&lt;code&gt;proc_pid_readdir&lt;/code&gt;方法。&lt;/li&gt;
&lt;li&gt;修改proc文件系统的某些模块：这个其实可以替换成自己实现一个模块，但是修改系统现成的可以省挺多事的。往模块中加入一些全局变量来实现自己的功能，如hidden_flag。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id="_4"&gt;实验过程&lt;a class="headerlink" href="#_4" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;添加系统调用，过程类似于实验2。&lt;/p&gt;
&lt;p&gt;修改系统调用表：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;% vim arch/i386/kernel/syscall_table.S&lt;/span&gt;
&lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="n"&gt;syscall_table&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;S&lt;/span&gt;
&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;long&lt;/span&gt; &lt;span class="n"&gt;sys_hide&lt;/span&gt;
&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;long&lt;/span&gt; &lt;span class="n"&gt;sys_hide_user_processes&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;增加系统调用实现：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;vim&lt;/span&gt; &lt;span class="n"&gt;kernel&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;hide&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;
&lt;span class="c1"&gt;// hide.c&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;linux/linkage.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;linux/sched.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;asm/current.h&amp;gt;&lt;/span&gt;

&lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt; * set the attribute hide of task with pid,&lt;/span&gt;
&lt;span class="cm"&gt; * according to the value of on.&lt;/span&gt;
&lt;span class="cm"&gt; *&lt;/span&gt;
&lt;span class="cm"&gt; * if on value is invalid (except for 1 and 0), return 0 to indicate.&lt;/span&gt;
&lt;span class="cm"&gt; * if current user is not root, return 1 to indicate.&lt;/span&gt;
&lt;span class="cm"&gt; * if pid is not exist, return 2 to indicate.&lt;/span&gt;
&lt;span class="cm"&gt; * return 3 to indicate success.&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="n"&gt;asmlinkage&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;sys_hide&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;pid_t&lt;/span&gt; &lt;span class="n"&gt;pid&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;on&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;uid&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// current user is not root&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;task_struct&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;find_task_by_pid&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pid&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;pid&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// pid is invalid&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;on&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;on&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;hide&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;on&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// success&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// on is invalid&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;vim&lt;/span&gt; &lt;span class="n"&gt;kernel&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;hide_user_processes&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;
&lt;span class="c1"&gt;// hide_user_processes.c&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;linux/linkage.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;linux/sched.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;asm/current.h&amp;gt;&lt;/span&gt;

&lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt; * hide processes with uid, accroing to binname, hide one or all.&lt;/span&gt;
&lt;span class="cm"&gt; *&lt;/span&gt;
&lt;span class="cm"&gt; * hide all processes when binname is NULL, otherwise, hide the process&lt;/span&gt;
&lt;span class="cm"&gt; * which binary name is equal to binname.&lt;/span&gt;
&lt;span class="cm"&gt; *&lt;/span&gt;
&lt;span class="cm"&gt; * if current user is not root, return 0 to indicate.&lt;/span&gt;
&lt;span class="cm"&gt; * return 1 to indicate success.&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="n"&gt;asmlinkage&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;sys_hide_user_processes&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;uid_t&lt;/span&gt; &lt;span class="n"&gt;uid&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;binname&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;uid&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;task_struct&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;binname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;for_each_process&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;uid&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;uid&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;hide&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;for_each_process&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;uid&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;uid&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;strcmp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;binname&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;comm&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;hide&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里简要描述下实现，都很简单，实现的开始都检查了当前的进程的uid是否为0，即是否为root，因为这些系统调用只能root用户使用。&lt;/p&gt;
&lt;p&gt;接着，&lt;code&gt;hide.c&lt;/code&gt;通过方法查找到对应pid的&lt;code&gt;task_struct&lt;/code&gt;指针，修改其内部的hide的值，这个hide是为了实验添加的，后面讲。&lt;/p&gt;
&lt;p&gt;而&lt;code&gt;hide_user_processes.c&lt;/code&gt;则通过&lt;code&gt;for_each_process&lt;/code&gt;遍历所有的&lt;code&gt;task_struct&lt;/code&gt;，将符合条件的修改hide进行隐藏。这里使用到的&lt;code&gt;p-&amp;gt;comm&lt;/code&gt;代表的是该&lt;code&gt;task_struct&lt;/code&gt;的二进制映像名称。&lt;/p&gt;
&lt;p&gt;继续完善系统调用的添加，修改&lt;code&gt;kernel/Makefile&lt;/code&gt;，&lt;code&gt;unistd.h&lt;/code&gt;，&lt;code&gt;syscalls.h&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;vim&lt;/span&gt; &lt;span class="n"&gt;kernel&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;Makefile&lt;/span&gt;
&lt;span class="c1"&gt;// Makefile&lt;/span&gt;
&lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;hide&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt; &lt;span class="n"&gt;hide_user_processes&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt; &lt;span class="n"&gt;goclis&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;

&lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;vim&lt;/span&gt; &lt;span class="n"&gt;include&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;asm&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;i386&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;unistd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt;
&lt;span class="c1"&gt;// unistd.h&lt;/span&gt;
&lt;span class="cp"&gt;#define __NR_hide                                  321&lt;/span&gt;
&lt;span class="cp"&gt;#define __NR_hide_user_processes        322&lt;/span&gt;

&lt;span class="cp"&gt;#define NR_syscalls                                 323&lt;/span&gt;

&lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;vim&lt;/span&gt; &lt;span class="n"&gt;include&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;linux&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;syscalls&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt;
&lt;span class="c1"&gt;// syscalls.h&lt;/span&gt;
&lt;span class="n"&gt;asmlinkage&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;sys_hide&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;pid_t&lt;/span&gt; &lt;span class="n"&gt;pid&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;on&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;asmlinkage&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;sys_hide_user_processes&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;uid_t&lt;/span&gt; &lt;span class="n"&gt;uid&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;binname&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意，要保持&lt;code&gt;NR_syscalls&lt;/code&gt;最大！系统调用添加完毕，下面修改&lt;code&gt;task_struct&lt;/code&gt;，添加hide属性：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;vim&lt;/span&gt; &lt;span class="n"&gt;include&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;linux&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;sched&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt;
&lt;span class="c1"&gt;// sched.h&lt;/span&gt;
&lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;task_struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="p"&gt;...&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;hide&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 1 to hide&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;既然为&lt;code&gt;task_struct&lt;/code&gt;添加了属性，就得为该属性进行初始化，而它的初始化发生在fork的时候，所以要进行相应修改：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;vim&lt;/span&gt; &lt;span class="n"&gt;kernel&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;fork&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;
&lt;span class="c1"&gt;// fork.c&lt;/span&gt;
&lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;do_fork&lt;/span&gt;&lt;span class="p"&gt;(...)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="p"&gt;...&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;IS_ERR&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;hide&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;...&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来，实现一下&lt;code&gt;/proc/hidden&lt;/code&gt;和&lt;code&gt;/proc/hidden_process&lt;/code&gt;的功能，显然，可以通过添加一个模块来实现它，但是，麻烦的是那样我们还得手动加载，不如修改现有模块来的方便，所以，下面通过修改&lt;code&gt;fs/proc/proc_misc.c&lt;/code&gt;这个模块来实现功能：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;vim&lt;/span&gt; &lt;span class="n"&gt;fs&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;proc&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;proc_misc&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;
&lt;span class="c1"&gt;// proc_misc.c&lt;/span&gt;
&lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="cp"&gt;#define BUFSIZE 1024&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;global_buffer&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;BUFSIZE&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;hidden_flag&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 1 enable hide function&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;proc_dir_entry&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;hidden_file&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;hidden_process_file&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;proc_read_hidden&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;page&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;off_t&lt;/span&gt; &lt;span class="n"&gt;off&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                            &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;cof&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;len&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sprintf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;page&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"%d"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;hidden_flag&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;proc_write_hidden&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                            &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;BUFSIZE&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;len&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;BUFSIZE&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;len&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;copy_from_user&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;global_buffer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;EFAULT&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;global_buffer&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="sc"&gt;'\0'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;hidden_flag&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;global_buffer&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="sc"&gt;'0'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;proc_read_hidden_process&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;page&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;off_t&lt;/span&gt; &lt;span class="n"&gt;off&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                                    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;cof&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hidden_flag&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;// no hide process&lt;/span&gt;
        &lt;span class="n"&gt;len&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sprintf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;page&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"No hide process.&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;task_struct&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;increment_length&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;process_seq_buf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;BUFSIZE&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="n"&gt;len&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;for_each_process&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;hide&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;increment_length&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sprintf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;process_seq_buf&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"%d "&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;pid&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="n"&gt;len&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;increment_length&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;len&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;process_seq_buf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="sc"&gt;'\0'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// remove the last blank space&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;process_seq_buf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="sc"&gt;'\0'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;len&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sprintf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;page&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"%s"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;process_seq_buf&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;__init&lt;/span&gt; &lt;span class="nf"&gt;proc_misc_init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;hidden_file&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;create_proc_entry&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"hidden"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mo"&gt;0644&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;hidden_file&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;read_proc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;proc_read_hidden&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;hidden_file&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;write_proc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;proc_write_hidden&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;hidden_process_file&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;create_proc_read_entry&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"hidden_process"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                            &lt;span class="mo"&gt;0444&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;proc_read_hidden_process&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;简单地解释一下，&lt;code&gt;global_buffer&lt;/code&gt;是为了供&lt;code&gt;copy_from_user&lt;/code&gt;将用户态的数据拷贝到内核态时使用，而全局变量&lt;code&gt;hidden_flag&lt;/code&gt;是&lt;code&gt;/proc/hidden&lt;/code&gt;中的内容的备份，用于供其他方法如&lt;code&gt;proc_pid_readdir&lt;/code&gt;使用，后面会描述。&lt;code&gt;proc_read_hidden&lt;/code&gt;和&lt;code&gt;proc_write_hidden&lt;/code&gt;分别为&lt;code&gt;/proc/hidden&lt;/code&gt;的读写回调方法，&lt;code&gt;/proc/hidden_process&lt;/code&gt;是个只读文件，为其指定读回调方法&lt;code&gt;proc_read_hidden_process&lt;/code&gt;，具体参见内核模块的内容。&lt;/p&gt;
&lt;p&gt;按照之前的思路分析，接下来该修改一些proc文件系统的方法来实现隐藏的功能，主要是修改以下几个方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;proc_pid_readdir&lt;/code&gt;：让其过滤掉隐藏的&lt;code&gt;task_struct&lt;/code&gt;，不返回给用户缓冲区。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;proc_pid_lookup&lt;/code&gt;：让其过滤掉隐藏的&lt;code&gt;task_struct&lt;/code&gt;，使得open不能解析类似&lt;code&gt;/proc/pid/xxx&lt;/code&gt;的路径名。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;vim&lt;/span&gt; &lt;span class="n"&gt;fs&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;proc&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;base&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;
&lt;span class="c1"&gt;// base.c&lt;/span&gt;
&lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="k"&gt;extern&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;hidden_flag&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;dentry&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nf"&gt;proc_pid_lookup&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;inode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;dir&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;dentry&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;dentry&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;nameidata&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;nd&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="p"&gt;...&lt;/span&gt;
    &lt;span class="n"&gt;rcu_read_lock&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;task&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;find_task_by_pid&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tgid&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;task&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hidden_flag&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;task&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;hide&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;goto&lt;/span&gt; &lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="n"&gt;get_task_struct&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;task&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;rcu_read_unlock&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;task&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;goto&lt;/span&gt; &lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;proc_pid_instantiate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dir&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;dentry&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;task&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;put_task_struct&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;task&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="nl"&gt;out&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;proc_pid_readdir&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;filp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;dirent&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;filldir_t&lt;/span&gt; &lt;span class="n"&gt;filldir&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="p"&gt;...&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;task&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;next_tgid&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tgid&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
         &lt;span class="n"&gt;task&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
         &lt;span class="n"&gt;put_task_struct&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;task&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;task&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;next_tgid&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tgid&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;tgid&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;task&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;pid&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hidden_flag&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;task&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;hide&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;flip&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;f_pos&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;tgid&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;TGID_OFFSET&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;proc_pid_fill_cache&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;filp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;dirent&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;filldir&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;task&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;tgid&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;put_task_struct&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;task&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                &lt;span class="k"&gt;goto&lt;/span&gt; &lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="c1"&gt;// task should be hidden&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;基本完成了，下面添加两个基础的程序用于测试：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;vim&lt;/span&gt; &lt;span class="n"&gt;hide&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;sys/syscall.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;argc&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"You should offer pid and on&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;pid&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;atoi&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;on&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;atoi&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;ret&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;syscall&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;321&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pid&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;on&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ret&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"System call error.&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ret&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"The value of on is invalid.&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ret&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Current user is not root.&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ret&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"The pid is invalid.&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ret&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Hide success.&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;vim&lt;/span&gt; &lt;span class="n"&gt;hide_all&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;sys/syscall.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;string.h&amp;gt;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;argc&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"You should offer uid and binname.&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;uid&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;atoi&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;binname&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;uid&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;// hide current user&lt;/span&gt;
        &lt;span class="n"&gt;uid&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;getuid&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;strcmp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;binname&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"NULL"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;binname&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;ret&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;syscall&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;322&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;uid&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;binname&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ret&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"System call error.&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ret&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Current user is not root.&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ret&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Hide success.&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;基于这两个程序进行测试：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;% cat /proc/hidden  &lt;span class="c"&gt;# 0&lt;/span&gt;
% cat /proc/hidden_process &lt;span class="c"&gt;# No hide process.&lt;/span&gt;
% gcc -o hide hide.c
% gcc -o hide_all hide_all.c

% ps aux &lt;span class="c"&gt;# all process&lt;/span&gt;
% ./hide &lt;span class="m"&gt;1&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt; &lt;span class="c"&gt;# hide pid 1&lt;/span&gt;
% ps aux &lt;span class="c"&gt;# no hide process because of hidden_flag == 0&lt;/span&gt;
% &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"1"&lt;/span&gt; &amp;gt; /proc/hidden
% ps aux &lt;span class="c"&gt;# pid 1 is hided.&lt;/span&gt;
% ls /proc &lt;span class="c"&gt;# can not find directory 1&lt;/span&gt;
% cat /proc/hidden_process &lt;span class="c"&gt;# 1&lt;/span&gt;
% ./hide &lt;span class="m"&gt;3&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt; &lt;span class="c"&gt;# hide pid 3&lt;/span&gt;
% ps aux &lt;span class="c"&gt;# pid 1 and 3 is hided.&lt;/span&gt;
% cat /proc/hidden_process &lt;span class="c"&gt;# 1 3&lt;/span&gt;
% ./hide &lt;span class="m"&gt;1&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="c"&gt;# show pid 1&lt;/span&gt;
% ps aux &lt;span class="c"&gt;# pid 3 is hided.&lt;/span&gt;
% cat /proc/hidden_process &lt;span class="c"&gt;# 3&lt;/span&gt;
% &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"0"&lt;/span&gt; &amp;gt; /proc/hidden
% ps aux &lt;span class="c"&gt;# no hide process because of hidden_flag == 0&lt;/span&gt;
% cat /proc/hidden_process &lt;span class="c"&gt;# No hide process.&lt;/span&gt;

% &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"1"&lt;/span&gt; &amp;gt; /proc/hidden
% ./hide_all -1 NULL &lt;span class="c"&gt;# hide all root processes&lt;/span&gt;
% ps aux
% cat /proc/hidden_process &lt;span class="c"&gt;# 1 2 3 ....&lt;/span&gt;
% ./hide &lt;span class="m"&gt;1&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="c"&gt;# show pid 1&lt;/span&gt;
% ps aux
% cat /proc/hidden_process &lt;span class="c"&gt;# 2 3...&lt;/span&gt;
% ./hide_all -1 init &lt;span class="c"&gt;# hide root process with binname 'init'&lt;/span&gt;
% ps aux
% cat /proc/hidden_process &lt;span class="c"&gt;# 1 2 3 ....&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="4-shell"&gt;实验4 实现Shell&lt;a class="headerlink" href="#4-shell" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;用户态编程，使用lex进行前端的词法分析，然后结合系统调用即可实现。&lt;/p&gt;
&lt;h3 id="_5"&gt;总结&lt;a class="headerlink" href="#_5" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;@_@坑还真不少，再次强调不具有普遍性，相同的步骤走下来，不对，可能根本走不到最后就出bug了。&lt;/p&gt;
&lt;h3 id="_6"&gt;参考资料&lt;a class="headerlink" href="#_6" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/18686114/cd-command-not-working-with-execvp"&gt;cd command not working with execvp&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://lxr.free-electrons.com/ident?v=2.6.24&amp;amp;i=uid_t"&gt;Linux Cross Reference&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary><category term="操作系统"></category></entry><entry><title>如何验证一个数字证书的有效性</title><link href="http://goclis.github.io/posts/2014/06/21/how-to-validate-certificate.html" rel="alternate"></link><updated>2014-06-21T15:43:00+08:00</updated><author><name>Goclis Yao</name></author><id>tag:goclis.github.io,2014-06-21:posts/2014/06/21/how-to-validate-certificate.html</id><summary type="html">&lt;p&gt;首先，设要验证的这个数字证书为B，则它必然由某个CA发放。这里假设该CA的数字证书是存在你的电脑上的或从B到根CA的数字证书都存放在你的电脑上（对于层次结构CA）。出于简单考虑，这里取单层CA做分析，即根CA的数字证书在你的电脑上，设为A，待验证的证书B是由其发放的。&lt;/p&gt;
&lt;p&gt;好了，假设完毕。首先看看这个待验证的证书包含哪些消息吧。&lt;/p&gt;
&lt;p&gt;对于一个RA（Registration Authority）的请求，CA会产生一对公私钥，公钥会被放在对应产生的数字证书中，私钥交给RA自己保管（怎么交的暂不考虑）。所以数字证书里必须包含的就是这个公钥。除此之外，还得有一系列的比如CA的名字，RA的信息等等。总之，这些信息会被包含成一个数字证书。&lt;/p&gt;
&lt;p&gt;既然数字证书产生了，但它终究是个有格式的文件，我们下步需要做的就是，保证它没有被篡改！所以，就需要颁发者对证书进行签名了，也就是对生成的数字证书进行摘要后，再用颁发者的私钥对其签名，然后将签名后的内容连同证书一起打包，这样才得到了一个可验证的完整的数字证书。&lt;/p&gt;
&lt;p&gt;用密码学表示一下大概就是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;// 设生成的中间数字证书为 MB，最终发放的为B
则B = MB || E(HASH(MB))  // 这里E是用CA的私钥加密， || 表示拼接
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来，看看是如何验证的（往下我们称MB为&lt;strong&gt;内部证书&lt;/strong&gt;，B为证书）：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从获取到的证书B开始，根据签发该证书的CA的信息，顺着层次树往上找，直到找到根证书，这样就可以构成一条&lt;strong&gt;证书链&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;从证书链的顶端，往下验证。提醒一点，按照我们的假设，这条证书链上的证书在我们的PC上都是有的。首先是根证书，根证书是自签名的，拿出它的公钥，对发证书时顺带的那个加了密的消息摘要进行解密，再对内部证书使用证书中定义的摘要算法进行处理，将产生的结果进行比较，匹配则往下。&lt;/li&gt;
&lt;li&gt;从根证书下来后就不再是自签名了，所以需要使用上层的公钥对发证书时顺带的消息摘要进行解密，然后同样地，对内部证书摘要，比较结果，匹配则往下。&lt;/li&gt;
&lt;li&gt;直至最后一个证书，如果摘要都匹配，说明这个证书是有效的，没被人篡改。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img alt="" src="http://ww2.sinaimg.cn/large/006y8lVagw1f86xyp8lupj30s009ygok.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;当然！这一切成立的前提都是根证书没有问题！！所以，对自己PC上根证书的管理千万不能松懈。&lt;/p&gt;</summary><category term="安全"></category><category term="数字证书"></category></entry><entry><title>动态载入和虚拟内存的按需调页的关联</title><link href="http://goclis.github.io/posts/2014/05/25/dynamic-load-and-virtual-memory-page-schedule-relation.html" rel="alternate"></link><updated>2014-05-25T17:20:00+08:00</updated><author><name>Goclis Yao</name></author><id>tag:goclis.github.io,2014-05-25:posts/2014/05/25/dynamic-load-and-virtual-memory-page-schedule-relation.html</id><summary type="html">&lt;p&gt;《操作系统概念》（第七版）第九章虚拟内存那章有如下这样一句话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;动态载入能够帮助减轻这一限制（将整个进程放入内存才能执行的限制），但是它需要程序员特别小心并且需要一些额外的工作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么，额外工作指的是？ 在网上基本上已经搜不到书上所说的动态载入了，基本上都是.dll或者.so之类的。 以下为个人理解，理解基于&lt;strong&gt;动态载入不需要操作系统提供特别支持&lt;/strong&gt;这一事实。&lt;/p&gt;
&lt;p&gt;动态载入是以子程序为单元的，也就将一个程序写成了许多的子程序。在使用到了某个子程序时，程序员需要在程序中编码以检查该子程序是否已在内存中，不在内存中时，需要编码将其动态载入，这里的程序员的&lt;strong&gt;编码&lt;/strong&gt;就是所谓的额外开销。比如下面这段代码（我不确定是否正确）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// so_obj是一个变量标识是否导入了某个.so&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;so_obj&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// load it here&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而虚拟内存是以页为单元的，一个程序被分放到了一些页上。而按需调页做到的是，当你在访问某一行代码，该代码在某一个不在内存中的页上时，操作系统会trap然后调页，从而将该代码所在页调入内存，从而看起来像是在“动态载入”了代码，但程序员没做任何事~&lt;/p&gt;
&lt;h3 id="update-at-2014-05-26"&gt;Update at 2014-05-26&lt;a class="headerlink" href="#update-at-2014-05-26" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;因为动态加载和动态链接在操作系统的实现上已经模糊了，所以此处的动态加载要做的工作实际上差不多和动态链接做的工作是一样的了，因此上面的理解是正确的。&lt;/p&gt;</summary><category term="操作系统"></category><category term="动态加载"></category><category term="虚拟内存换页"></category></entry><entry><title>动态链接和动态载入的区别</title><link href="http://goclis.github.io/posts/2014/05/21/difference-between-dynamic-link-and-dynamic-load.html" rel="alternate"></link><updated>2014-05-21T15:32:00+08:00</updated><author><name>Goclis Yao</name></author><id>tag:goclis.github.io,2014-05-21:posts/2014/05/21/difference-between-dynamic-link-and-dynamic-load.html</id><summary type="html">&lt;p&gt;大致的理解如下，不一定正确，确认后会更新：&lt;/p&gt;
&lt;p&gt;按照一般的步骤，用户程序在执行前会经历以下几个步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;编译汇编&lt;/li&gt;
&lt;li&gt;链接（将编译出来的模块和其他引用了的模块合并）&lt;/li&gt;
&lt;li&gt;加载（从硬盘加载到内存中）&lt;/li&gt;
&lt;li&gt;执行（在内存中执行）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;动态加载和动态链接是打破以上所描述的常规行为的。&lt;/p&gt;
&lt;h3 id="_1"&gt;动态加载&lt;a class="headerlink" href="#_1" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;硬盘上存储了一个已经生成好的目标模块，但是这个目标模块是由许多子程序组成的。每时每刻，不一定所有的子程序都需要在内存中，所以，在使用到相应子程序时再把其加载到内存中来使用，这要求用户在编写程序时合理地编写子程序，不需要操作系统提供特别的支持。&lt;/p&gt;
&lt;h3 id="_2"&gt;动态链接&lt;a class="headerlink" href="#_2" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;它与动态加载的概念相似，但是，它不是将加载延迟到了执行时，而是将链接延迟到执行时。主要的问题就在于理解这句话。对于动态链接，磁盘上存储着的目标模块中包含着一部分它并未链接的模块（但是它迟早要用，所以动态链接嘛~）。而使用动态加载技术时，你动态加载的模块是经过链接之后的，也就是该模块已经结合了所有它会用到的模块，只是在你程序的不同地方使用了，所以在不同的地方动态加载需要的代码。&lt;/p&gt;
&lt;p&gt;动态链接的实现是依赖于存根（stub）的，目标模块中在使用需要动态链接的模块的地方使用存根来代替，存根能够指出如何装入以及装入后的程序在内存的哪。&lt;/p&gt;
&lt;p&gt;动态链接的好处在于多个程序使用到了一个相同的模块时，不需要将该模块都像常规步骤或者动态加载那样合并到目标模块中，而是在执行时再动态链接，这样在内存中就只用存在一份该模块的代码了，即实现了共享库。&lt;/p&gt;
&lt;h3 id="update-at-2014-05-26"&gt;Update at 2014-05-26&lt;a class="headerlink" href="#update-at-2014-05-26" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;问了老师之后，再自己查了查wiki之后有了更深的理解。
首先，上面的理解依旧是正确的，只是不那么准确，看看wiki的吧。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;动态加载&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Dynamic loading is a mechanism by which a computer program can, at run time, load a library (or other binary) into memory, retrieve the addresses of functions and variables contained in the library, execute those functions or access those variables, and unload the library from memory. Unlike static linking and loadtime linking, this mechanism allows a computer program to start up in the absence of these libraries, to discover available libraries, and to potentially gain additional functionality. &lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;大致的意思就是说动态加载是在运行时把一个library或者二进制文件调入内存，取出其中的functions或者variables来使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;动态链接&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In computing, a dynamic linker is the part of an operating system (OS) that loads (copies from persistent storage to RAM) and links (fills jump tables and relocates pointers) the shared libraries needed by an executable at run time, that is, when it is executed. The specific operating system and executable format determine how the dynamic linker functions and how it is implemented. Linking is often referred to as a process that is performed at compile time of the executable while a dynamic linker is in actuality a special loader that loads external shared libraries into a running process and then binds those shared libraries dynamically to the running process. This is also called dynamic or late linking. The specifics of how a dynamic linker functions is operating-system dependent. &lt;sup id="fnref:2"&gt;&lt;a class="footnote-ref" href="#fn:2" rel="footnote"&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看上去比起动态加载貌似只多了一个共享吧？&lt;/p&gt;
&lt;p&gt;实际上，动态链接做的不止是动态加载，还有链接的工作。回想我们在一开始说的那个常规步骤就可以明白了。&lt;/p&gt;
&lt;p&gt;其实，这两个概念在现在操作系统的实现上已经混合了，没有纯粹的&lt;strong&gt;动态加载&lt;/strong&gt;了，都是基于动态链接做的了，比如windows的dll和linux的.so都是如此。&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr/&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Dynamic_loading"&gt;Dynamic Loading&lt;/a&gt; &lt;a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:2"&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Dynamic_linker"&gt;Dynamic Linker&lt;/a&gt; &lt;a class="footnote-backref" href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</summary><category term="操作系统"></category><category term="动态链接"></category><category term="动态加载"></category></entry></feed>